<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>深入理解Java虚拟机 | Hexo</title>
  <meta name="keywords" content="">
  <meta name="description" content="深入理解Java虚拟机 | Hexo">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="动态代理  12345678910111213141516171819202122232425262728293031323334353637383940414243import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;interface M">
<meta property="og:type" content="article">
<meta property="og:title" content="动态代理">
<meta property="og:url" content="http://example.com/2023/10/08/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="动态代理  12345678910111213141516171819202122232425262728293031323334353637383940414243import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;interface M">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2023/10/08/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/image-20231010095434654.png">
<meta property="og:image" content="http://example.com/2023/10/08/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/image-20231010095514037.png">
<meta property="og:image" content="http://example.com/2023/10/08/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/image-20231010095540647.png">
<meta property="og:image" content="http://example.com/2023/10/08/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/image-20231010095611220.png">
<meta property="article:published_time" content="2023-10-08T14:49:01.662Z">
<meta property="article:modified_time" content="2023-10-10T02:35:59.272Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/10/08/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/image-20231010095434654.png">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 6.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>John Doe</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-rss"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/yelog"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="facebook"
               href="https://www.facebook.com/faker.tops"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-facebook"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
            <a title="instagram"
               href="https://www.facebook.com/faker.tops"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-instagram"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="reddit"
               href="https://www.reddit.com/user/yelog/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-reddit"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="weibo"
               href="http://weibo.com/u/2307534817"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-weibo"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="jianshu"
               href="https://www.jianshu.com/u/ff56736de7cf"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-jianshu"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="zhihu"
               href="https://www.zhihu.com/people/jaytp/activities"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-zhihu"></use>
                    </svg>
                
            </a>
        
    
        
    
        
            <a title="oschina"
               href="https://my.oschina.net/yelog"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-oschina"></use>
                    </svg>
                
            </a>
        
    
        
    
        
            <a title="email"
               href="mailto:jaytp@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=872336115&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="kugou"
               href="https://www.kugou.com/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-kugou"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="neteasemusic"
               href="https://music.163.com/#/user/home?id=88151013"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-neteasemusic"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(9)</small>
            
        </div>
    </li>
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">About</a>
        
        <a style="width: 50%"
                
                                           class="friends">Friends</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="9">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="All "
           href="/2023/11/22/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="力扣刷题">力扣刷题</span>
            <span class="post-date" title="2023-11-22 17:10:44">2023/11/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/10/08/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="动态代理">动态代理</span>
            <span class="post-date" title="2023-10-08 22:49:01">2023/10/08</span>
        </a>
        
        
        <a  class="All "
           href="/2023/04/08/%E9%A1%B9%E7%9B%AERPC%E6%A1%86%E6%9E%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="项目RPC框架">项目RPC框架</span>
            <span class="post-date" title="2023-04-08 19:49:23">2023/04/08</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/02/redis/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="redis">redis</span>
            <span class="post-date" title="2023-01-02 17:46:17">2023/01/02</span>
        </a>
        
        
        <a  class="All "
           href="/2022/12/24/MySQL/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MySQL">MySQL</span>
            <span class="post-date" title="2022-12-24 11:40:50">2022/12/24</span>
        </a>
        
        
        <a  class="All "
           href="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java并发编程">Java并发编程</span>
            <span class="post-date" title="2022-11-11 16:20:42">2022/11/11</span>
        </a>
        
        
        <a  class="All "
           href="/2022/10/30/JVM%E8%B0%83%E4%BC%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JVM调优">JVM调优</span>
            <span class="post-date" title="2022-10-30 20:09:07">2022/10/30</span>
        </a>
        
        
        <a  class="All "
           href="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="深入理解Java虚拟机">深入理解Java虚拟机</span>
            <span class="post-date" title="2022-10-19 10:40:02">2022/10/19</span>
        </a>
        
        
        <a  class="All "
           href="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="计算机网络">计算机网络</span>
            <span class="post-date" title="2022-02-06 18:11:21">2022/02/06</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-深入理解Java虚拟机" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">深入理解Java虚拟机</h1>
    
    <div class="article-meta">
        
        
        
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2023-11-24 20:11:10'>2022-10-19 10:40</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            Views 👀 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-text">第二章 Java内存区域与内存溢出异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F"><span class="toc-text">运行时数据区域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="toc-text">对象的访问定位</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">对象的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-text">对象的内存布局</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-text">第三章 垃圾收集器与内存分配策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E6%AD%BB%E4%BA%A1"><span class="toc-text">1.判断对象是否死亡</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-text">引用计数法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-text">可达性分析算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-text">引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-text">2.垃圾收集算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%90%86%E8%AE%BA"><span class="toc-text">分代收集理论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-text">标记-清除算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-text">标记-复制算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-text">标记-整理算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-HotSpot%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-text">3.HotSpot算法实现细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%85%B8%E5%9E%8B%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">4.典型的垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CMS"><span class="toc-text">CMS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">G1收集器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E6%9D%83%E8%A1%A1"><span class="toc-text">垃圾收集器的权衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="toc-text">内存分配与回收策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E3%80%81%E4%BA%94%E7%AB%A0-JVM%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%8F%8A%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98"><span class="toc-text">第四、五章 JVM监控和故障处理及内存调优</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-text">第六章 类文件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%85%B3%E6%80%A7%E5%9F%BA%E7%9F%B3"><span class="toc-text">无关性基石</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-text">Class文件结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-text">第七章 虚拟机类加载机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA"><span class="toc-text">类加载时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-text">类加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD"><span class="toc-text">加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81"><span class="toc-text">验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%86%E5%A4%87"><span class="toc-text">准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90"><span class="toc-text">解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">类加载器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="toc-text">虚拟机字节码执行引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84"><span class="toc-text">运行时栈帧结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-text">方法调用</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="第二章-Java内存区域与内存溢出异常"><a href="#第二章-Java内存区域与内存溢出异常" class="headerlink" title="第二章 Java内存区域与内存溢出异常"></a>第二章 Java内存区域与内存溢出异常</h2><h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p><strong>程序计数器</strong><br>是一块较小的内存空间，可以理解为当前线程所执行的<strong>字节码行号指示器</strong>，字节码解释器的工作就是通过改变这个计数器的值选取下一条要执行的字节码指令<br>虚拟机的多线程通过线程轮流切换、分配处理器执行时间来实现，任意时刻一个内核只会执行一条线程中的指令。因此，为了线程切换后能恢复正确的执行位置，每个线程需要各自享有一个独立的程序计数器，。<br>如果线程执行的是一个java方法，计数器记录的是正在执行的虚拟机字节码指令的地址；如果是本地方法，PC计数器为空。<br>不会出现OOM错误</p>
<p> <strong>虚拟机栈</strong><br> 每个线程单独享有一个虚拟机栈，栈中的元素是栈帧，栈帧中包含局部变量表、操作栈、动态连接、方法出口等信息，一个方法从调用到结束对应着栈帧的入栈和出栈<br> 局部变量表存储了基本数据类型、引用类型、returnAddress类型，存储以Slot为单位。每个方法要用栈帧中局部变量表多大的空间编译时就确定了，运行时不会改变。但是注意，空间指的槽的数量，槽的大小由虚拟机自行决定。<br> 虚拟机栈可能出现两种异常情况：<br>如果线程申请的虚拟机栈的深度大于虚拟机允许的最大空间，会造成StackOverflowError；如果虚拟机栈容量是可拓展的，那么在栈拓展过程中遇到本机内存空间不够的情况，会OOM的错误（HotSpot默认栈不可拓展）</p>
<p><strong>本地方法栈</strong><br>它的作用和虚拟机栈类似，只是为本地方法服务</p>
<p><strong>java堆</strong><br>java堆是线程共享的，他是所有对象实例和数组创建的地方。堆中的内存可以不是物理连续，但一定要是逻辑连续的，但是在遇到大对象的创建时（例如大数组对象）HotSpot也会要求物理连续来节省内存访问与分配的开销<br>java堆虽然是线程共享的，但是为了节省分配新对象的开销，我们可能会在堆中划分出多个线程私有的分配缓冲区（TLAB），从而解决线程不安全的问题</p>
<p><strong>方法区</strong><br>方法区是线程共享的一块内存区域，用来存储已经被虚拟机已加载的类型信息、静态变量以及常量、即时编译后的代码缓存等信息。<br>在JDK8以前，我们用永久代来实现方法区，实际上也是把垃圾收集器的分代设计拓展到方法区。之后我们利用元空间实现方法区。元空间来自本地内存，所以这样设计不容易内存溢出<br><strong>运行时常量池</strong>是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有的常量池表，用来存储编译生成的各种字面量和符号引用。这些内容会在类加载之后存放在运行时常量池中。除此保存Class文件中描述的符号引用外，它还把由符号引用翻译出来的直接引用也存在里面。<br>相较于常量池表，它有动态性，在程序运行过程中也可以向常量池表中添加新常量。例如String::intern()</p>
<p><strong>直接内存</strong><br>直接内存并不是运⾏时数据区的⼀部分，但是这部分内存也被频繁地使⽤，⽽且也可能导致OutOfMemoryError异常出 现，本机直接内存的分配不会受到Java堆⼤⼩的限制，但是会受到本机总内存以及处理器寻址空间的 限制</p>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><ul>
<li>首先，虚拟机遇到一条字节码new指令时，会首先去检查<strong>这个指令的参数能否在常量池中定位到一个类的符号引用</strong>，并检查这个符号引用代表的类是否被加载解析初始化过了，要是没有就先执行类的加载过程</li>
<li>然后，在类加载检查通过后，虚拟机为新对象在堆中分配内存（所需大小在类加载完成过后便可确定）。有两种分配方式：<br><strong>指针碰撞</strong>：<br>内存规整，用过的和没用过的内存各自分开，中间用指针作为分界点指示器，分配内存就是把指针往空闲空间方向移动一段与对象大小相等的距离。<br><strong>空闲列表</strong>：<br>记录那些内存可用<br>举个栗子1.Serial，ParNew自带压缩整理，内存分配算法用的是碰撞指针，简单高效<br>2.CMS基于清除算法，空间杂乱。为了对象分配更快，设计了叫Linear Allocation Buffer 的分配缓冲区，利用空闲列表得到一大块分配缓冲区后，在里面仍然可以用指针碰撞来分配。</li>
<li>内存分配完成后，给除了对象头外的内存空间初始化为<strong>零值</strong>.如果 使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。这步操作保证了对象的实例字段 在Java代码中可以不赋初始值就直接使用</li>
<li>接下来，对对象头进行必要的设置，例如他的类元信息、对象的哈希码（实际上用到Object::hashCode()才会计算）、对象的GC分代年龄信息等</li>
<li>执行&lt;init&gt;()方法，即构造函数（对于程序来说这才是真正的创建对象）</li>
</ul>
<h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p><strong>对象头</strong><br>1.储存对象自身的运行时数据，包括哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等<br>2.类型指针，即对象指向它的类型元数据的指针。如果对象是数组，对象头还要记录数组长度<br><strong>实例数据</strong><br>对象真正存储的有效信息，父类和子类的字段。相同宽度的字段总是分配到一起存放，在满足这个条件的前提下，父类变量会出现在子类前。如果-XX ：Compact Fields 参数为true，那子类之中较窄的变量也能插入父类变量的空隙中，以节省空间<br><strong>对齐填充</strong><br>占位符，任何对象的大小必须是8字节的整数倍</p>
<p><strong>句柄引用访问</strong><br>线程的虚拟机栈的栈帧中的本地变量表的reference类型数据，它存放的并不是在堆中的对象实例本身，而是指向了一个句柄池。句柄池存放着类类型指针和对象实例指针。这样通过二次访问的方式我们找到对象实例，但是访问效率肯定不如直接访问高。<br>垃圾回收进行对象实例位置移动是很常见的现象，而移动对象只需要改变句柄指针的内容，而不用改变reference的值，这是句柄访问的优点</p>
<p><strong>直接指针访问</strong><br>对象的布局分布必须考虑存放访问类型数据的相关信息，reference存的直接就是对象地址。速度快，节省了一次指针定位的时间开销</p>
<h2 id="第三章-垃圾收集器与内存分配策略"><a href="#第三章-垃圾收集器与内存分配策略" class="headerlink" title="第三章 垃圾收集器与内存分配策略"></a>第三章 垃圾收集器与内存分配策略</h2><p>GC 要做三件事，哪些内存需要回收（对象是否死亡）、什么时候回收、怎么回收（回收算法）</p>
<h3 id="1-判断对象是否死亡"><a href="#1-判断对象是否死亡" class="headerlink" title="1.判断对象是否死亡"></a>1.判断对象是否死亡</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a><strong>引用计数法</strong></h4><p>对象中添加引用计数器，每当有一个地方引用它，计数器加一，引用失效，计数器减一。计数器为零的对象可被回收</p>
<p>&#x3D;&#x3D;问题：无法解决对象之间循环引用的问题&#x3D;&#x3D;</p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a><strong>可达性分析算法</strong></h4><p>从一系列 <code>GC Roots</code> 根对象，按照引用关系向下搜索，搜索过程走过的路径为引用链，如果某个对象到GC Roots间没有任何引用链相连，证明对象是垃圾</p>
<blockquote>
<p><code>GC Roots</code>对象可以是</p>
</blockquote>
<blockquote>
<ul>
<li>虚拟机栈（<strong>栈帧中的本地变量表</strong>）中引用的对象，例如各个线程被调用的方法堆栈中的参数、局部变量、临时变量等</li>
<li><strong>方法区中静态属性、常量</strong>引用的对象。例如字符串常量池中的引用</li>
<li>被<strong>同步锁(synchronized)持有</strong>的对象</li>
<li>虚拟机内部的引用，如基本数据类型对应的 Class 对象，异常对象（<code>NullPointException</code> <code>OutOffMemoryError</code>） 系统类加载器</li>
</ul>
</blockquote>
<p>宣告对象死亡需要 两个标记过程：</p>
<blockquote>
<ol>
<li><p>如果对象在可达性分析后发现没有和GC Roots相连的引用链，那会被第一次标记</p>
</li>
<li><p>然后再一次筛选，筛选的条件是是否有必要执行Finalize（）方法</p>
<p>2.1 如果对象没有覆盖finalize()方法，或finalize()方法已经被调用过一次，那么方法不会被执行，对象死亡</p>
<p>2.2 如果对象有必要执行finalize()方法，则会被放置在F-Queue队列中，由虚拟机自动创建的、低调度优先级的 Finalizer 线程去执行 Finalize() 方法，看能否自救成功（比如把this赋值给某个成员变量）</p>
</li>
</ol>
</blockquote>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><ul>
<li>强引用<ul>
<li>即普遍存在的引用赋值，强引用的对象不会回收</li>
</ul>
</li>
<li>软引用<ul>
<li>描述有用但非必须的对象，内存不够时回收，SoftReference 类实现软引用</li>
</ul>
</li>
<li>弱引用<ul>
<li>描述非必须对象，发生GC时会被回收，WeakReference 类实现弱引用</li>
</ul>
</li>
<li>虚引用<ul>
<li>唯一作用对象被回收时得到一个系统通知，不能通过虚引用得到实例，PhantomReference 类实现虚引用</li>
</ul>
</li>
</ul>
<h3 id="2-垃圾收集算法"><a href="#2-垃圾收集算法" class="headerlink" title="2.垃圾收集算法"></a>2.垃圾收集算法</h3><h4 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a><strong>分代收集理论</strong></h4><p>（1）弱分代假说：绝大多数对象朝生夕灭<br>（2）强分代假说：熬过多次垃圾收集的对象难以消灭<br>（3）跨代引用假说：跨代引用相对于同代引用占极少数，几存在相互引用关系的两个对象，倾向于同时生存、同时消亡</p>
<blockquote>
<p>所以，不用为了少量的跨代引用去扫描整个老年代，也不用浪费空间专门记录每个对象是否存在以及存在哪些跨代引用。</p>
<p>只需在新生代上建立一个全局数据结构 <strong>记忆集</strong> ，该结构把老年代划分成若干小块，标识老年代哪块有跨代引用。</p>
<p>MinorGC 时，只将包含跨代引用的内存的对象加入 GC Roots扫描，虽然引用关系改变时有维护开销，但比每次扫描整个老年代要划算</p>
</blockquote>
<h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a><strong>标记-清除算法</strong></h4><p>（1）&#x3D;&#x3D;标记&#x3D;&#x3D;：标记出要回收的对象</p>
<p>（2）&#x3D;&#x3D;清除&#x3D;&#x3D;：回收掉标记的对象</p>
<p><strong>缺点：</strong></p>
<ul>
<li>&#x3D;&#x3D;执行效率不稳定&#x3D;&#x3D;，如果堆中包含大量对象并且大部分要回收，会进行大量的标记和清除动作，&#x3D;&#x3D;执行效率随对象数量增长而降低&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;内存空间碎片化&#x3D;&#x3D;，以后分配大对象可能无法找到连续的内存而触发另一次垃圾回收</li>
</ul>
<p><img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20230307101808110.png"></p>
<h4 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a><strong>标记-复制算法</strong></h4><p>为解决<strong>面对大量可回收对象执行效率低</strong>问题，提出“半区复制”，将可用内存按容量划分成两块，将存活对象复制到另外一块，然后已使用的内存空间清理掉</p>
<p><strong>优点：</strong></p>
<ul>
<li>对于<strong>多数对象都是可回收的情况</strong>，复制少数存活对象性能好</li>
<li>因为针对半区进行内存回收，不会出现<strong>空间碎片</strong></li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>如果<strong>大多数对象存活，复制开销大</strong></li>
<li><strong>浪费一半空间</strong>，如果不想浪费50%空间，就要<strong>分配担保</strong></li>
</ul>
<p><img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20230307102148014.png"></p>
<blockquote>
<p>复制算法实现新生代，分成Eden区和两块Survivor区，比例8：1：1</p>
<p>每次分配内存只使用Eden和一块Survivor，GC时将存活对象一次性复制到另一块Survivor（新生代可用空间为整个新生代容量的90%）</p>
<p><strong>分配担保</strong>：<strong>当Survivor空间不足以容纳一次 Minor GC 后存活的对象</strong>，需要通过分配担保机制进入老年代</p>
</blockquote>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a><strong>标记-整理算法</strong></h4><p>（1）&#x3D;&#x3D;标记&#x3D;&#x3D;：可回收对象</p>
<p>（2）&#x3D;&#x3D;整理&#x3D;&#x3D;：<strong>让所有存活对象向空间一端移动，然后直接清理掉边界以外的内存</strong></p>
<p><img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20230307103904391.png"></p>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>移动存活对象</strong>并<strong>更新引用</strong>负担重，并且要全程<strong>暂停用户线程</strong>（STW）。让内存回收更复杂</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>让内存分配和访问更高效，因为<strong>没有碎片化空间</strong>。总体上虽然增加延迟，但是提高了吞吐量</li>
</ul>
<p><strong>应用场景：</strong></p>
<ul>
<li>标记-复制 算法完全不考虑移动、整理存活对象，空间碎片造成内存分配、内存访问更复杂（比如 通过“分区空闲分配链表”解决），影响系统吞吐量</li>
<li>整理存活对象——<strong>内存回收</strong>更复杂，系统吞吐量高；不整理——<strong>内存分配</strong>更复杂，GC停顿时间短</li>
<li>关注<strong>吞吐量</strong>的<strong>Parallel Scavenge</strong>使用整理算法；关注<strong>延迟</strong>的<strong>CMS</strong>使用复制算法</li>
</ul>
<h3 id="3-HotSpot算法实现细节"><a href="#3-HotSpot算法实现细节" class="headerlink" title="3.HotSpot算法实现细节"></a>3.HotSpot算法实现细节</h3><p><strong>根节点枚举</strong><br>固定可作为GC Roots的节点主要在全局性的引用（常量、静态属性）和执行上下文（本地变量表）中，找到这些根节点，并不需要逐个寻找。虚拟机用OopMap数据结构记录哪些地方存在对象引用，一旦类加载动作完成时，HotSpot会把对象内什么偏移量上是什么类型的数据计算出来，即时编译过程中也在特定位置会记录下栈里和寄存器里哪些位置是引用<br><strong>安全点</strong><br>在OopMap的协助下，HotShot快速准确完成GC Roots枚举。实际上HotShot没有为每条指令都生成OopMap，而只是在特定位置记录这些信息，称为安全点。垃圾收集强制要求必须执行到安全点后才能暂停<br><strong>记忆集</strong><br>记忆集是一种用于记录从非收集区指向收集区的指针集合的抽象数据结构。收集器只需要通过记忆集判断出某一块非收集区是否存在指向收集区的指针就可以了，并不需要了解跨代指针的全部细节<br><strong>卡表</strong>定义了记忆集的记录精度、与堆内存的映射关系<br><strong>写屏障</strong><br>通过写屏障维护卡表状态，看作对“引用类型字段赋值”这个动作的AOP切面，在引用对象赋值时会产生环形通知，供程序做额外动作。直到G1出现前，其他收集器只用了写后屏障。<br>除了写屏障的开销外，卡表在高并发场景下面临“伪共享”问题。当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，会彼此影响导致性能降低。解决方法是不使用无条件的写屏障<br><strong>并发的可达性分析</strong><br>遍历对象图，采用三色标记。如果和用户线程并发，可能有两种后果：<br>1.原本消亡的对象标记成存活，产生浮动垃圾<br>2.原本存活的对象标记成消亡，不能容忍。产生条件为</p>
<blockquote>
<p>赋值器插入了一条或多条黑色到白色对象的新引用<br>删除了全部灰色到该白色对象的直接或间接引用</p>
</blockquote>
<p>解决方法：<br>1.增量更新：黑色对象一旦插入指向白色对象的引用后，就把他变成灰色。如 CMS<br>2.原始快照（SATB）：记录下删除的引用，以灰色对象为根，重新扫描一次 如 G1 Shenandoah</p>
<h3 id="4-典型的垃圾收集器"><a href="#4-典型的垃圾收集器" class="headerlink" title="4.典型的垃圾收集器"></a>4.典型的垃圾收集器</h3><p><img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20230307105438999.png"></p>
<p><strong>Serial</strong><br>单线程收集器，它只会使用一个处理器或一条收集线程去完成垃圾收集工作，并且要暂停其他所有工作线程STW，知道收集结束是HotShot在<strong>客户端</strong>模式下默认的新生代收集器。与其他收集器的单线程比，简单高效，额外内存消耗最少。对于处理器核心数较少的环境来说，Serial由于没有线程交互的开销，可以得到最高的单线程收集效率。<br><strong>PerNew</strong><br>多线程并行收集器，运行于<strong>服务器</strong>模式下的虚拟机，可以配合CMS工作<br>服务器模式下推荐的组合，曾经是PerNew+CMS，现在是G1。现在可以理解为，PerNew合并到CMS，成为CMS专门处理新生代的组成部分</p>
<blockquote>
<p>并行（Parallel）：描述多条垃圾回收线程之间的关系。同一时间有多条回收线程协同工作，默认用户线程处于等待状态<br>并发（Concurrent）：描述垃圾回收线程和用户线程之间的关系，同一时间两种线程都在运行。由于用户线程未冻结，所以程序仍然能相应服务器请求，但由于垃圾收集线程占用了一部分系统资源，此时应用程序处理的吞吐量受影响</p>
</blockquote>
<p><strong>Parallel Scavenge收集器</strong><br>类似PerNew是多线程并行收集器，关注点是达到一个可控制的<strong>吞吐量</strong>（吞吐量是处理器用于运行用户代码的时间和处理器总消耗时间的比值），也叫“吞吐量优先处理器”<br>停顿时间越短，越适合需要与用户交互或需要保证服务响应质量的程序<br>高吞吐量可以高效利用处理器资源，适合在后台运算而不需要而不需要太多交互分析的任务<br>控制吞吐量的参数</p>
<blockquote>
<p>最大垃圾收集停顿时间 -XX: MaxGCPauseMillis<br>直接设置吞吐量大小 -XX: GCTimeRatio<br>自适应调节开关 -XX: +UseAdaptiveSizePolicy，动态调整新生代大小、比例，晋升老年代对象老年代大小等细节参数，以提供最合适的停顿时间或最大的吞吐量</p>
</blockquote>
<p><strong>自适应调节策略</strong>也是Parallel Scavenge区别于ParNew的重要特征</p>
<p><strong>Serial Old收集器</strong><br>单线程收集器，老年代，标记整理算法<br>客户端模式：和Serial结合<br>服务器模式：作为CMS收集器并发失败的后备方案</p>
<p><strong>Parallel Old收集器</strong><br>多线程并行收集，老年代，标记整理算法<br>注重吞吐量或处理器资源比较稀缺时，可以考虑 Parallel Scavenge+Parallel Old</p>
<h4 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a><strong>CMS</strong></h4><p>第一款真正意义上<strong>支持并发</strong>的垃圾收集器，以<strong>获取最短停顿时间</strong>为目标<br>应用场景：互联网网站或者基于浏览器的B&#x2F;S系统的服务器上，关注<strong>响应速度</strong>和<strong>交互体验</strong></p>
<p>CMS <code>concurrent mark swap</code>基于<strong>标记-清除</strong>算法实现：<br><strong>（1）初始标记</strong> <code>STW 标记GC Roots 能直接关联到的对象</code><br><strong>（2）并发标记</strong><code>（增量更新）从GCRoots 直接关联的对象开始遍历整个对象图的过程</code><br><strong>（3）重新标记</strong> <code>修正并发标记期间，因用户程序继续运作导致标记产生变动的对象的标记记录</code><br>**（4）并发清除  **<code>由于不需要移动存活对象，可以和用户线程并发</code></p>
<p><img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20230307110124989.png"></p>
<p>&#x3D;&#x3D;<strong>优点：</strong>&#x3D;&#x3D;</p>
<ul>
<li>并发收集、低停顿</li>
</ul>
<p>&#x3D;&#x3D;<strong>缺点：</strong>&#x3D;&#x3D;</p>
<ul>
<li><p>&#x3D;&#x3D;对处理器资源十分敏感&#x3D;&#x3D;。&#x3D;&#x3D;并发&#x3D;&#x3D;阶段虽然不会导致用户线程停顿，但会因为占用了一部分线程而导致应用程序变慢，&#x3D;&#x3D;降低总吞吐量&#x3D;&#x3D;</p>
</li>
<li><p>&#x3D;&#x3D;无法处理浮动垃圾&#x3D;&#x3D;，可能产生并发失败而导致STW的Full GC</p>
<blockquote>
<p>CMS并发标记和并发清除阶段，由于用户线程还在运行，不断产生未被标记的新垃圾，只能下一次GC再清理掉。所以CMS不能像其他收集器一样等到老年代几乎被填满再收集，它必须预留空间满足程序分配新对象的需要，否则就会出现并发失败<code>Concurrent Mode Failure</code>，冻结用户线程，临时启用<code>Serial Old</code>进行老年代垃圾收集</p>
<p>所以，参数<code>-XX:CMSInitiatingOccupancyFraction</code>设置太高然而容易因产生大量并发失败二降低性能</p>
</blockquote>
</li>
<li><p>3.基于&#x3D;&#x3D;标记-清除&#x3D;&#x3D;算法实现，产生大量内存碎片。当没用空间分配新对象时，提前触发 <code>Full GC</code></p>
</li>
</ul>
<h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a><strong>G1收集器</strong></h4><p>取代<code>Parallel Scavenge+Parallel Old</code>组合，成为<strong>服务端</strong>模式下的默认垃圾收集器</p>
<p><strong>&#x3D;&#x3D;Mixed GC 模式&#x3D;&#x3D;<strong>：面向堆内存任何部分来组成回收集，衡量标准不再是它属于哪一代，而是</strong>哪块内存存放的垃圾最多，回收收益最大</strong></p>
<p>开创<strong>基于Region的堆内存布局</strong>，把Java堆划分成多个大小相等的独立区域（Region），每个 Region 可以根据需要扮演 Eden、Survior、老年代。G1 根据 Region 扮演的不同角色采用 不同的处理策略。</p>
<p>Region 的 <strong><code>Humongouns</code>区域，存储大对象</strong>。大小超过 Region 一半就是大对象</p>
<blockquote>
<p><code>-XX: G1HeapRegionSize</code> 设定 Region大小（1MB- 32MB，2^N）超大对象存放于多个Humogous Region，并被视为老年代</p>
</blockquote>
<p><strong>为什么G1能建立可预测的停顿时间模型？</strong></p>
<p><strong>将Region作为单次回收的最小单元</strong>，关注Region里面垃圾堆积的<strong>价值</strong>，即回收所获得的空间大小以及回收所需时间的经验值。后台维护优先级列表，根据用户用户允许的停顿时间，优先处理那些回收收益最大的Region</p>
<p>跨Region区引用问题：<br>每个Region维护自己的记忆集，记录别的Region指向自己的指针，并标记这些指针在哪些卡页范围内。本质是哈希表，key是别的Region的起始地址，value是集合存储卡表的索引号，。由于Region数量比传统分代收集器的分代数量多，所以有更高的内存占用</p>
<p>基于标记整理算法实现：<br>1.初始标记<br>2.并发标记：原始快照（SATB）。为保证新对象分配，每个Region设计了两个TAMS指针，新分配的对象地址在两个TAMS之上，被隐式标记，默认存活<br>3.最终标记<br>4.筛选回收</p>
<p>优点：指定最大停顿时间、分Region内存布局、按收益动态确定回收集、无内存碎片<br>缺点：内存占用、额外执行负荷</p>
<h3 id="垃圾收集器的权衡"><a href="#垃圾收集器的权衡" class="headerlink" title="垃圾收集器的权衡"></a>垃圾收集器的权衡</h3><p>三指标： 吞吐量、延迟、内存占用<br>1.应用程序的主要关注点是什么？</p>
<blockquote>
<p>数据分析、科学计算，目标是尽快算出结果——吞吐量<br>SLA应用，停顿时间影响服务质量，严重可能导致事务超时——延迟<br>客户端应用或嵌入式应用——内存占用</p>
</blockquote>
<p>2.运行应用的基础设施如何？</p>
<blockquote>
<p>硬件规格，涉及到的系统架构是x86-32&#x2F;64、SPARC还是ARM&#x2F;Aarch64；处理器数量、分配内存大小；操作系统</p>
</blockquote>
<p>3.JDK发行商、版本</p>
<h3 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h3><p><strong>对象优先在Eden分配</strong><br>⼤多数情况下，对象在新⽣代Eden区中分配。当Eden区没有⾜够空间进⾏分配时，虚拟 机将发起⼀次Minor GC。<br><strong>大对象直接进入老年代</strong><br>-XX: PretenureSizeThreshold参数，超过该参数的对象会直接在老年代分配。为了避免Eden和两个Survior区之间来回复制，产生大量内存复制操作<br><strong>长期存活对象进入老年代</strong><br>-XX: MaxTenuringThreshold 超过年龄进入老年代。如果在Surivivor空间中相同年龄所有对象大小总和大于Survivor空间的一半，年龄大于等于该年龄的对象可以直接进入老年代<br><strong>空间分配担保</strong><br>Minor GC前，检查老年代最大可用连续空间是否大于新生代所有对象总空间。成立则进行，不成立检查是否允许担保失败。允许，则检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小，大于则尝试进行一次Minor GC，小于或者不允许担保失败，进行Full GC。</p>
<h2 id="第四、五章-JVM监控和故障处理及内存调优"><a href="#第四、五章-JVM监控和故障处理及内存调优" class="headerlink" title="第四、五章 JVM监控和故障处理及内存调优"></a>第四、五章 JVM监控和故障处理及内存调优</h2><p><strong>性能监控和故障处理工具</strong><br>jsp：输出虚拟机中运行的进程状态信息<br>jstat：持续观察虚拟机内存中各个分区的使用率以及GC的统计数据<br>jmap：查看堆内存的使用情况<br>jstack：查看java进程内线程堆栈信息，结合日志可以迅速定位到问题线程<br>JMC：分析本地应用以及连接远程ip使用，提供实时分析线程、内存、CPU、GC等信息的可视化界面</p>
<h2 id="第六章-类文件结构"><a href="#第六章-类文件结构" class="headerlink" title="第六章 类文件结构"></a>第六章 类文件结构</h2><h3 id="无关性基石"><a href="#无关性基石" class="headerlink" title="无关性基石"></a>无关性基石</h3><ul>
<li><p>语言无关性</p>
<ul>
<li>实现语言无关性的基础是【虚拟机】和【字节码存储格式】</li>
<li>虚拟机不与任何程序语言绑定，它只和“Class文件”这种特定的二进制文件格式所关联</li>
<li>其他任何语言的实现者都可以将 Java 虚拟机作为语言的运行基础，以 Class 文件作为产品的交付媒介</li>
</ul>
<img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20221116132246640.png" alt style="zoom:50%;">
</li>
<li><p>平台无关性</p>
<ul>
<li>各种不同平台的【Java虚拟机】，以及所有平台都统一支持的【程序存储格式——字节码】，是构成平台无关性的基石</li>
<li>开发商开发出的各种平台上的虚拟机，屏蔽掉了各个平台操作系统和机器指令集的不同性，不同平台的虚拟机识别相同的 Class 文件，实现 Java 等语言的“一次编译，到处运行”</li>
</ul>
</li>
</ul>
<h3 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h3><p>Java 技术保持良好的向后兼容性，Class 文件结构的稳定功不可没</p>
<p>任何一个Class文件都对应着唯一的一个类或接口的定义信息，但是类或接口不一定都要定义在文件里（比如可以动态生成，直接送入类加载器中）<br>Class文件是以8个字节为基础单位的二进制流，各个数据项严格按顺序紧凑排列在文件当中，中间没有任何分隔符。当遇到占用8字节以上空间的数据项时，会按照高位在前方式分割成若干8个字节</p>
<p>Class 文件只有两种数据类型：</p>
<ul>
<li>无符号数：是基本数据类型，以 u1，u2，u4，u8 表示对应字节的无符号数，描述数字、索引引用、数量值、按照UTF-8编码构成的字符串值</li>
<li>表：多个无符号数或其他表作为数据项构成的复合数据结构，”_info“ 结尾。整个 Class 文件本质也可看做一张表</li>
</ul>
<img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20221116142558649.png" alt style="zoom:50%;">

<p><strong>魔数</strong></p>
<p>​	占 4 字节，确认文件是否为一个能被虚拟机接受的文件（不用拓展名识别身份，更安全），值为 0xCAFEBABE</p>
<p><strong>版本号</strong></p>
<pre><code>1. 前两个字节是次版本号，不常用，主要用于测试版本
1. 后两个字节是主版本号，高版本 JDK 能向下兼容以前版本的 Class 文件，但不能运行以后版本的 Class 文件。《Java虚拟机规范》规定，即使文件格式未发生变化，虚拟机也拒绝运行超过其版本号的 Class 文件
</code></pre>
<img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20221116143341963.png" alt style="zoom:50%;">

<blockquote>
<p>比如，一个版本号为 0x0032 （十进制 50）的 Class 文件，只能被 JDK 6 或以上版本的虚拟机执行 </p>
</blockquote>
<p><strong>常量池</strong></p>
<ol>
<li><p>Class 文件中第一个出现的表类型数据项目，存放字面量和符号引用</p>
</li>
<li><p>常量池入口有 u2 类型数据，表示常量池容量计数值（constant_pool_count）</p>
<blockquote>
<p>注意：计数从 1 开始</p>
<p>比如，常量池容量为 0x0016（十进制 22），表示常量池有 21 项常量 （1-21），如果某些指向常量池的索引值为 0，表示不引用任何一个常量池项目</p>
</blockquote>
</li>
</ol>
<ul>
<li><p>字面量</p>
<blockquote>
<p> 类似常量，如文本字符串、被声明为final的常量值等</p>
</blockquote>
</li>
<li><p>符号引用：</p>
<blockquote>
<p>被模块导出或者开放的包<br>类和接口的全限定名<br>字段的名称和描述符<br>方法的名称和描述符<br>方法句柄和方法类型<br>动态调用点和动态常量</p>
</blockquote>
</li>
</ul>
<p>​		当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址中<br><strong>访问标志</strong><br>​	1. 常量池结束后，紧接着两字节表示访问标志（access_flag），识别一些类或接口的访问信息，包括：Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明final等<br>​	1. access_flag 共 16 个标志位可用，只定义了 9 个，没用到的一律为 0</p>
<h2 id="第七章-虚拟机类加载机制"><a href="#第七章-虚拟机类加载机制" class="headerlink" title="第七章 虚拟机类加载机制"></a>第七章 虚拟机类加载机制</h2><p>Java 虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、解析、初始化等过程，最终形成可被虚拟机直接使用的 Java 类型，称为虚拟机类的加载机制。</p>
<img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20221116163240786.png" alt style="zoom:40%;">

<p>Java 中，类的加载、链接、初始化都是在，程序运行期间完成的：</p>
<ul>
<li><p>缺点：提前编译带来困难，类加载增加性能开销</p>
</li>
<li><p>运行期动态加载、动态连接，提高可拓展性、灵活性</p>
<blockquote>
<p>应用：Applet、JSP、OSGi、</p>
</blockquote>
</li>
</ul>
<h3 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h3><p>加载、验证、准备、初始化、卸载 这五个阶段顺序确定，解析阶段不一定，可以在初始化以后再进行（运行时动态绑定&#x2F;晚绑定）</p>
<p><strong>主动引用</strong></p>
<p>《Java虚拟机规范》没有强制约束类什么时候加载，但是规定了【有且仅有】六种情况要立刻进行类的 初始化：</p>
<ul>
<li>遇到<code>new</code> 、<code>getstatic</code>、<code>putstatic</code>、<code>invokestatic</code>这四条字节码指令<ul>
<li><code>new</code>实例化对象</li>
<li>设置或读取一个类型的静态字段（被<code>final</code>修饰、已在编译期把结果放进常量池的静态字段除外）</li>
<li>调用一个类型的静态方法时</li>
</ul>
</li>
<li>使用<code>java.lang.reflect</code>包的方法对类型进行反射调用时</li>
<li>初始化类时，发现父类还没初始化，要先初始化父类</li>
<li>先初始化主类</li>
<li>如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析结果为<code>REF_getStatic</code>、<code>REF_putStatic</code>、<code>REF_invokeStatic</code>、 <code>REF_newInvokeSpecial</code>四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化</li>
<li>一个接口定义了默认方法<code>default</code>，如果这个接口的实现类发生初始化，接口要在它之前初始化</li>
</ul>
<p>注意：对于静态字段，<strong>只有直接定义这个字段的类才会被初始化</strong>，因此通过子类引用父类定义的静态字段，只会触发父类初始化而不会触发子类<br>接口不能用static语句块，但编译器也会接口生成<clinit>()类构造器，用于初始化接口定义的成员变量。接口初始化不要求父接口全部完成初始化，只有在真正使用到父接口时（如引用接口定义的的常量）才会初始化</clinit></p>
<p><strong>被动应用</strong></p>
<ul>
<li>通过子类调用父类的静态字段，不会导致子类初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>通过数组来引用类，不会导致此类初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，不会触发定义常量的类的初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>补充</strong></p>
<ul>
<li>访问【编译期常量】<ul>
<li>常量的值可以在编译期间确定，访问该常量时不会引起常量所在类的初始化</li>
</ul>
</li>
<li>访问【运行期常量】<ul>
<li>常量的值不可以在编译期间确定，访问该常量时会引起常量所在类的初始化</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>接口初始化不要求父接口初始化，真正用到父接口（引用接口中定义的常量）才会初始化（除了含<code>default</code>方法的接口）</li>
</ul>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a><strong>加载</strong></h4><ul>
<li><p>通过一个类的【全限定名】获取类的二进制字节流</p>
<blockquote>
<p>没有要求怎样获取、从哪里获取，具有很强的灵活性</p>
<p>比如：从 ZIP 压缩包获取——JAR、WAR；网络中获取——Web Applet；动态代理；由其他文件生成——JSP 等</p>
</blockquote>
</li>
<li><p>将这个字节流所代表的静态存储结构转化为【方法区】的运行时数据结构</p>
</li>
<li><p>内存中生成一个代表这个类的的【java.lang.Class对象】，作为方法区这个类的各种数据的访问入口</p>
</li>
</ul>
<blockquote>
<p>非数组类型加载（准确说是加载阶段中获取类的二进制字节流的动作）可控性最强，既可以用内置的引导类加载器，也可以用用户自定义的类加载器，程序员通过定义自己的类加载器控制字节流的获取方式（重写类加载器的findClass()或loadClass()），赋予应用程序获取运行代码的动态性<br>数组类本身不通过类加载器创建，由虚拟机在内存中动态构建出来。但元素类型最终要靠类加载器加载。加载过程如下：</p>
<blockquote>
<p>  如果数组的组件类型是引用类型，递归加载这个组件类型，数组将被标识在加载该组件类型的类加载器的类名称空间上<br>  如果数组的组件类型不是引用类型，数组标记为与引导类加载器关联<br>  数组类的可访问性和它的组件类型一致，如果组件类型不是引用类型，默认public</p>
</blockquote>
</blockquote>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a><strong>验证</strong></h4><p>1.文件格式验证</p>
<blockquote>
<p>验证字节流是否符合Class文件格式的规范：</p>
<ul>
<li>是否一魔数0xCAFEBABE开头</li>
<li>主、次版本号是否在当前虚拟机接受范围内</li>
<li>常量池常量是否有不被支持的常量类型（检查常量tag标志）</li>
<li>指向常量的索引值是否有指向不存在的常量或不符合类型的常量</li>
<li>CONSTANT_UTF8_info型常量是否有不符合UTF8编码的数据</li>
<li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息<br>验证目的：保证输入的字节流能正确的解析并存储于方法区之内。<br>文件格式验证基于二进制字节流，通过后字节流才允许进入虚拟机内存的方法区进行存储，后面三个阶段的验证全部基于方法区的存储结构，不会直接读取、操作字节流了</li>
</ul>
</blockquote>
<p>2.元数据验证</p>
<blockquote>
<p>对字节码描述的信息进行<strong>语义分析</strong></p>
<ul>
<li>这个类是否有父类（除了java.lang.Object，都应该有父类）</li>
<li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）</li>
<li>如果这个类不是抽象类，是否实现了父类或接口中要求实现的方法</li>
<li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类final字段，出现不合规格的方法重载）</li>
</ul>
</blockquote>
<p>3.字节码验证</p>
<blockquote>
<p>最复杂的阶段，通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的</p>
<ul>
<li>保证任意时刻操作数栈的数据类型与指令代码序列能配合工作</li>
<li>保证任意时刻跳转指令不会跳转到方法体以外的字节码指令上</li>
<li>保证方法体中的类型转换总是有效的</li>
</ul>
</blockquote>
<p>4.符号引用验证</p>
<blockquote>
<p>符号引用验证发生在解析阶段（将符号引用转化为直接引用）。符号引用验证可以看作对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，目的是保证解析行为能正常进行</p>
<ul>
<li>符号引用中通过字符串描述的全限定名能否找到对应类</li>
<li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段</li>
<li>符号引用中的类、字段、方法的可访问性是否能被当前类访问</li>
</ul>
</blockquote>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a><strong>准备</strong></h4><p>准备阶段为类中定义的静态变量分配内存并设置类变量初始值。JDK8以后，类变量会随着Class对象放到堆中，这时类变量在方法区是一种逻辑上的概念<br>注意：准备阶段仅仅分配类变量，不包括实例变量，实例变量会在对象实例化时随和对象分配在堆中。<br>初始值一般指零值，真正给类变量赋规定的值的putstatic指令，是在类构造器<clinit>()方法中，在类的初始化阶段才会进行。<br>特殊情况下，如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量会被初始化为ConstantValue指定的值</clinit></p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a><strong>解析</strong></h4><p>符号引用：<br>以一组符号来描述所引用的目标。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存中的内容<br>直接引用：<br>可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。和内存布局直接相关，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不同。如果有了直接引用，目标必定在虚拟机内存中存在<br>注意：如果⼀个符号引⽤之前已经被成功解析 过，那么后续的引⽤解析请求就应当⼀直能够成功;同样地，如果第⼀次解析失败了，其 他指令对这个符号的解析请求也应该收到相同的异常，哪怕这个请求的符号在后来已成功 加载进Java虚拟机内存之中</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><strong>初始化</strong></h4><p>是类加载过程最后一个步骤，真正开始执行类中编写的Java代码，将主导权移交给Java程序<br>执行类构造器&lt; clinit&gt;()方法，这是javac编译器的自动生成物，由编译器自动收集类中所有类变量的赋值动作和静态语句块（static）中的语句合并产生。编译器收集的顺序由语句在源文件中出现的顺序决定，静态语句块只能访问到定义静态语句块之前的变量，定义在他之后的变量，静态语句块只能赋值，不能访问<br>&lt; clinit&gt;()方法不用显式的调用父类构造器，虚拟机会保证父类&lt; clint&gt;()在子类执行前已经执行完毕。<br>执⾏接⼝的()⽅法不需要先执⾏⽗接⼝ 的()⽅法，只有当⽗接⼝中定义的变量被使⽤时，⽗接⼝才会被初始化<br>同一个类加载器下，一个类型只会被初始化一次</p>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>类加载阶段中“通过一个类的全限定名获取描述类的二进制字节流”这个动作放到虚拟机外部去实现，以便让应用程序自己决定如何让获取所需的类。实现这个动作的代码称为“类加载器”</p>
<p>&#x3D;&#x3D;如何确定类的唯一性？&#x3D;&#x3D;</p>
<ul>
<li><p>任意一个类，都必须由加载他的【类加载器】和这个【类本身】一起确立唯一性</p>
</li>
<li><p>每个类加载器，都有一个独立的类名称空间</p>
</li>
<li><p>比较两个类是否相等，只有这两个类由同一个类加载器加载的前提下才有意义，否则一定不相等</p>
</li>
</ul>
<p>&#x3D;&#x3D;三层类加载器：&#x3D;&#x3D;</p>
<ul>
<li><p>启动类加载器（Bootstrap ClassLoader）:</p>
<ul>
<li><p>由C++实现，是虚拟机的一部分。负责加载存放在&lt; JAVA_HOME&gt;\bin目录，或者被-Xbootclasspath参数指定路径中存放的，而且虚拟机能识别的类库，加载到虚拟机内存中。</p>
</li>
<li><p>扩展类加载器（Extension ClassLoader）：<br>加载&lt; JAVA_HOME&gt;\lib\ext目录，或者被java.ext.dirs系统变量指定路径中所有的类库。这是Java系统类库的扩展机制，开发者可以直接在程序中使用扩展类加载器加载Class文件<br>应用程序类加载器（Application ClassLoader）：<br>加载用户类路径（ClassPath）上所有类库</p>
</li>
</ul>
</li>
</ul>
<p><strong>双亲委派模型</strong><br>如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器区完成，每一层次的类加载器都是如此，因此所有的加载请求最终传送到顶层的启动类加载器，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围没有找到所需的类），子类加载器才会尝试自己加载</p>
<p><strong>破坏双亲委派模型</strong><br>双亲委派模型解决了各个类加载器协作时基础类型的一致性问题（越基础的类越由上层加载器加载）。<br>基础类型要调用回用户的代码：线程上下文加载器，通过java.lang.Thread类的setContext-ClassLoader()方法进行设置，默认是应用程序类加载器。<br>JNDI服务使用线程上下文类加载器加载所需SPI服务代码，即父类加载器请求子类加载器完成类加载动作</p>
<h2 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h2><h3 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h3><p><strong>动态连接</strong><br>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，为了支持方法调用过程中的动态连接</p>
<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>方法调用阶段的唯一任务就是<strong>确定被调用方法的版本</strong>，暂时未涉及方法内部的具体运行过程<br><strong>解析</strong><br>调用目标在程序代码写好、编译器进行编译的那一刻就已经确定下来了，这类方法的调用成为解析</p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 jaytp@qq.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">💰</a>
</p>






    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2020 Yelog
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>Help us with donation</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">alipay</label></span><span><label><input type="radio" name="pay" value="weixin">weixin</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
