<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Java并发编程 | Hexo</title>
  <meta name="keywords" content="">
  <meta name="description" content="Java并发编程 | Hexo">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="Linux参考资料：韩顺平-一周学会Linux    电子书《跟阿铭学Linux》 chatGPT 概述GNU&#x2F;Linux 是一种类 Unix 操作系统内核的开源操作系统。它最初由芬兰程序员 Linus Torvalds 在1991年创建。Linux 内核是一个用 C 语言编写的软件，它提供了操作系统的核心功能。 一些常见的 Linux 发行版包括 Ubuntu、Fedora、Debia">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux">
<meta property="og:url" content="http://example.com/2024/01/05/Linux/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Linux参考资料：韩顺平-一周学会Linux    电子书《跟阿铭学Linux》 chatGPT 概述GNU&#x2F;Linux 是一种类 Unix 操作系统内核的开源操作系统。它最初由芬兰程序员 Linus Torvalds 在1991年创建。Linux 内核是一个用 C 语言编写的软件，它提供了操作系统的核心功能。 一些常见的 Linux 发行版包括 Ubuntu、Fedora、Debia">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2024/01/05/Linux/up.gif">
<meta property="og:image" content="http://example.com/2024/01/05/Linux/image-20231230174300620.png">
<meta property="og:image" content="http://example.com/2024/01/05/Linux/image-20231222165518186.png">
<meta property="og:image" content="http://example.com/2024/01/05/Linux/image-20231222165707309-1703755608191-2.png">
<meta property="og:image" content="http://example.com/2024/01/05/Linux/image-20231228173233107.png">
<meta property="og:image" content="http://example.com/2024/01/05/Linux/image-20231228174126285.png">
<meta property="og:image" content="http://example.com/2024/01/05/Linux/image-20231228174342958.png">
<meta property="og:image" content="http://example.com/2024/01/05/Linux/image-20231228174619191.png">
<meta property="og:image" content="http://example.com/2024/01/05/Linux/image-20231228174659390.png">
<meta property="og:image" content="http://example.com/2024/01/05/Linux/image-20231228174948292.png">
<meta property="og:image" content="http://example.com/2024/01/05/Linux/image-20231228175116971.png">
<meta property="og:image" content="http://example.com/2024/01/05/Linux/image-20231228180229052.png">
<meta property="og:image" content="http://example.com/2024/01/05/Linux/image-20231228214820448.png">
<meta property="og:image" content="http://example.com/2024/01/05/Linux/image-20231228215318583.png">
<meta property="og:image" content="http://example.com/2024/01/05/Linux/image-20231228220621267.png">
<meta property="og:image" content="http://example.com/2024/01/05/Linux/image-20240103131341600.png">
<meta property="article:published_time" content="2024-01-05T05:29:00.000Z">
<meta property="article:modified_time" content="2024-01-05T05:30:20.593Z">
<meta property="article:author" content="王才雨">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/01/05/Linux/up.gif">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 6.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>王才雨</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/dalaizi"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:1935863093@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=1935863093&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(10)</small>
            
        </div>
    </li>
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">About</a>
        
        <a style="width: 50%"
                
                                           class="friends">Friends</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="10">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="All "
           href="/2024/01/05/Linux/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Linux">Linux</span>
            <span class="post-date" title="2024-01-05 13:29:00">2024/01/05</span>
        </a>
        
        
        <a  class="All "
           href="/2023/11/22/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="力扣刷题">力扣刷题</span>
            <span class="post-date" title="2023-11-22 17:10:44">2023/11/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/10/08/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="动态代理">动态代理</span>
            <span class="post-date" title="2023-10-08 22:49:01">2023/10/08</span>
        </a>
        
        
        <a  class="All "
           href="/2023/04/08/%E9%A1%B9%E7%9B%AERPC%E6%A1%86%E6%9E%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="项目RPC框架">项目RPC框架</span>
            <span class="post-date" title="2023-04-08 19:49:23">2023/04/08</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/02/redis/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="redis">redis</span>
            <span class="post-date" title="2023-01-02 17:46:17">2023/01/02</span>
        </a>
        
        
        <a  class="All "
           href="/2022/12/24/MySQL/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MySQL">MySQL</span>
            <span class="post-date" title="2022-12-24 11:40:50">2022/12/24</span>
        </a>
        
        
        <a  class="All "
           href="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java并发编程">Java并发编程</span>
            <span class="post-date" title="2022-11-11 16:20:42">2022/11/11</span>
        </a>
        
        
        <a  class="All "
           href="/2022/10/30/JVM%E8%B0%83%E4%BC%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JVM调优">JVM调优</span>
            <span class="post-date" title="2022-10-30 20:09:07">2022/10/30</span>
        </a>
        
        
        <a  class="All "
           href="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="深入理解Java虚拟机">深入理解Java虚拟机</span>
            <span class="post-date" title="2022-10-19 10:40:02">2022/10/19</span>
        </a>
        
        
        <a  class="All "
           href="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="计算机网络">计算机网络</span>
            <span class="post-date" title="2022-02-06 18:11:21">2022/02/06</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-Java并发编程" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Java并发编程</h1>
    
    <div class="article-meta">
        
        
        
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2023-11-24 19:46:12'>2022-11-11 16:20</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            Views 👀 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E7%BA%BF%E7%A8%8B"><span class="toc-text">Java线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">线程的实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="toc-text">java线程实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-text">1. 创建线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B"><span class="toc-text">2. 查看线程进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#windows%EF%BC%9A"><span class="toc-text">windows：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#linux%EF%BC%9A"><span class="toc-text">linux：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%EF%BC%9A"><span class="toc-text">java：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-text">3. 线程运行原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E6%A0%88%E5%B8%A7"><span class="toc-text">栈和栈帧</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-text">上下文切换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">4. 常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-text">5. 线程状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-%E4%B8%8E%E5%8D%8F%E7%A8%8B"><span class="toc-text">java 与协程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-text">线程安全问题及其解决方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#park-unpark"><span class="toc-text">park &amp; unpark</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">使用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-text">原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E5%BC%8F%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-text">阻塞式悲观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#synchroned"><span class="toc-text">synchroned</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock"><span class="toc-text">Lock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88-JMM-%EF%BC%89"><span class="toc-text">Java 内存模型（ JMM ）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS-%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%96%B9%E5%BC%8F"><span class="toc-text">CAS 非阻塞方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS-%E7%9B%B8%E5%85%B3-API"><span class="toc-text">CAS 相关 API</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadPoolExecuter"><span class="toc-text">ThreadPoolExecuter</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-text"></span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="toc-text">工厂方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#newFixedThreadPool"><span class="toc-text">newFixedThreadPool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#newCachedThreadPool"><span class="toc-text">newCachedThreadPool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#newSingleThreadExecutor"><span class="toc-text">newSingleThreadExecutor</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1"><span class="toc-text">提交任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">关闭线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-text">优点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AQS-%E5%8E%9F%E7%90%86"><span class="toc-text">AQS 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E6%A0%B8%E5%BF%83%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-text">三个核心组成部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-text">资源共享方式：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%81"><span class="toc-text">自定义锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock%E5%8E%9F%E7%90%86"><span class="toc-text">ReentrantLock原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E9%94%81%E6%B5%81%E7%A8%8B"><span class="toc-text">加锁流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%94%81%E8%BF%87%E7%A8%8B"><span class="toc-text">解锁过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantReadWriteLock"><span class="toc-text">ReentrantReadWriteLock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Semaphore"><span class="toc-text">Semaphore</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CountDownLatch"><span class="toc-text">CountDownLatch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CyclicBarrier"><span class="toc-text">CyclicBarrier</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88%E7%B1%BB"><span class="toc-text">线程安全集合类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-text">ConcurrentHashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentLinkedQueue"><span class="toc-text">ConcurrentLinkedQueue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CopyOnWriteArrayList"><span class="toc-text">CopyOnWriteArrayList</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>许多场景下，需要计算机同时处理多项任务，不仅是因为计算机的运算能力强大，还有一个更重要的原因是计算机的运算速度和它的存储和通信子系统的速度差异过大，大部分时间都花费在磁盘 IO、网络通信、数据库访问等。</p>
<p>另外，一个服务器要同时为多个客户端提供服务，TPS（一秒内服务端平均响应的请求总数）与程序的并发能力有密切关系。</p>
<ul>
<li><p><strong>进程</strong></p>
<ul>
<li>进程就是用来加载指令、管理内存、管理IO的，当一个程序被运行，从磁盘加载这个程序的代码到内存，就开启了一个进程。</li>
<li>进程可以看成<strong>程序的实例</strong>，大部分程序可以同时运行多个实例进程（浏览器），有的程序只能启动一个实例进程（网易云音乐、360安全卫士）</li>
<li>进程是<strong>【资源分配的最小单位】</strong></li>
</ul>
</li>
<li><p><strong>线程</strong></p>
<ul>
<li>一个进程可以分成一至多个线程。一个线程就是一个指令流，将一条条指令按顺序交给CPU执行。<strong>共享进程的资源<br>最小调度单元</strong></li>
<li>windows中进程不活动，只是线程的容器</li>
</ul>
</li>
<li><p>并行</p>
<ul>
<li>微观、宏观都并行。不同线程同一时间用不同CPU核</li>
</ul>
</li>
<li><p>并发</p>
<ul>
<li>微观串行，宏观并行。线程轮流使用CPU</li>
</ul>
</li>
<li><p>对于方法调用：</p>
<ul>
<li>同步：需要等待结果返回，才能继续进行</li>
<li>异步：不需要等待结果返回，就能继续进行</li>
</ul>
</li>
</ul>
<h2 id="Java线程"><a href="#Java线程" class="headerlink" title="Java线程"></a>Java线程</h2><h3 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a><strong>线程的实现方式</strong></h3><ul>
<li><p>内核线程实现：</p>
<p>也称为 1：1 实现。内核线程（KLT）就是由操作系统内核支持的线程，这种线程通过内核来完成线程切换，内核通过任务调度器对线程调度，并负责将线程的任务映射到各个处理器上</p>
<p>程序一般使用内核线程的高级接口——轻量级进程（LWP）。这种轻量级进程和内核线程 1：1 的关系称为一对一线程模型</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221110210513731.png" alt="image-20221110210513731" style="zoom:46%;">

<ul>
<li><p>优点：</p>
<p>由于内核线程的支持，每个轻量级进程成为一个独立的调度单元，不会出现整个进程阻塞的情况</p>
</li>
<li><p>缺点：</p>
<p>基于内核线程实现，上下文切换需要在用户态和内核态切换，调度代价高；</p>
<p>每个轻量级进程需要一个内核线程支持，消耗一定内核资源（如内核线程的栈空间），因此系统支持的轻量级进程数量有限</p>
</li>
</ul>
</li>
<li><p>用户线程实现</p>
<p>这种进程和用户线程之间 1：N 的关系称为一对多的线程模型。狭义上的用户线程指完全建立在用户空间的线程库上，系统内核不能感知用户线程的存在和实现。</p>
<ul>
<li><p>优点</p>
<p>没有系统内核的支援，用户线程的建立、同步、销毁、调度全在用户态完成，避免了内核态和用户态切换的性能损耗，能支持更大规模的线程数量</p>
</li>
<li><p>缺点</p>
<p>没有系统内核的援助，所有线程操作都需要用户程序自己去处理。由于操作系统只把处理器资源分配给进程，阻塞处理、线程映射到处理器上 等复杂操作要用户程序自己处理</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221110211848521.png" alt="image-20221110211848521" style="zoom:40%;"></li>
</ul>
</li>
<li><p>混合实现</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221110212114732.png" alt="image-20221110212114732" style="zoom:45%;"></li>
</ul>
<h3 id="java线程实现"><a href="#java线程实现" class="headerlink" title="java线程实现"></a>java线程实现</h3><p>对于 HotSpot ，每个 java 线程直接映射到一个操作系统原生内核线程，中间没有额外的间接结构。因此，JVM 不会干涉线程调度（可以设置线程优先级给操作系统线程调度提建议），由操作系统全权决定。</p>
<h3 id="1-创建线程"><a href="#1-创建线程" class="headerlink" title="1. 创建线程"></a>1. 创建线程</h3><ol>
<li>使用 <strong>匿名内部类</strong> 继承 <strong>Thread 类</strong> 创建线程，原理是通过直接重写 <strong>Thread类</strong> 的 <code>run</code>方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个继承 Thread 的匿名内部类</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;name&quot;</span>) &#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  <span class="comment">//匿名子类重写了父类中的 run 方法</span></span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//本质是运行了自身覆盖的run代替了Thread.run()</span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用 <strong>匿名内部类</strong> 实现 <strong>Runnable 接口</strong>。 配合 Thread ,【线程】和【任务】分离。将Runnable任务当作参数投到继承Thread的匿名内部类中，执行 Thread 的 run 方法，而 Thread 的 run 方法转而去执行 Runnable 的 run 方法</li>
</ol>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230314113627074.png" alt="image-20230314113627074" style="zoom:67%;">

<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230314113701720.png" alt="image-20230314113701720" style="zoom:67%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建任务</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建线程对象</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task，<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">//本质是通过Thread.run()调用了Runnable.run()</span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<p> 使用 Runnable 的优点：</p>
<ul>
<li><strong>更容易和线程池等高级 API 配合</strong>，因为任务和线程分离了，我们只需要将任务扔到线程池里就行，而不是之前那种任务和线程耦合在一起</li>
<li><strong>让任务类脱离了Thread继承体系</strong>，更灵活（组合优于继承）我的线程可以执行不同任务，一个任务也不用和一个线程相绑定</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用lambda</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    <span class="comment">//do somenthing</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用<strong>匿名内部类</strong>继承 <strong>FutureTask</strong> 类， FutureTask 配合 Thread，执行有返回值的任务</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FutureTask接收Callable类型的参数，处理有返回结果的情况</span></span><br><span class="line">FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line"><span class="comment">//主线程阻塞，同步等待task执行完毕的结果</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> task.get();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Callable 和 Runnable 区别：</p>
<ul>
<li>Callable 规定方法是 call，Runnable 规定方法是 run</li>
<li>Callable 执行任务<strong>有返回值</strong>，Runnable 没有。返回值通过Future.get 得到</li>
<li>call 方法能<strong>抛出异常</strong>，run 不能</li>
<li>运行 Callable 任务可以拿到一个 Future 对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过 Future 对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</li>
</ul>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230314115015972.png" alt="image-20230314115015972" style="zoom:50%;">

<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230314115038448.png" alt="image-20230314115038448" style="zoom:50%;">
</blockquote>
<h3 id="2-查看线程进程"><a href="#2-查看线程进程" class="headerlink" title="2. 查看线程进程"></a>2. 查看线程进程</h3><h4 id="windows："><a href="#windows：" class="headerlink" title="windows："></a>windows：</h4><ul>
<li>任务管理器</li>
<li><code>tasklist</code> 查看进程</li>
<li><code>taskkill</code> 杀死进程</li>
</ul>
<h4 id="linux："><a href="#linux：" class="headerlink" title="linux："></a>linux：</h4><ul>
<li><code>ps -fe</code> 查看所有进程</li>
<li><code>ps -fT -p &lt; pid&gt;</code> 查看某个进程的所有线程</li>
<li><code>kill</code> 杀死进程</li>
<li><code>top</code> 可以动态查看进程或线程的信息，包括 PID， 内存、CPU 占用率，显示资源占用情况</li>
<li><code>top -H -p &lt; pid&gt;</code> 查看某个进程的所有线程。-H :查看线程 -p：指定进程ID</li>
</ul>
<h4 id="java："><a href="#java：" class="headerlink" title="java："></a>java：</h4><ul>
<li><code>jps</code> :查看所有java进程</li>
<li><code>jstack &lt; pid&gt;</code>：查看某个java进程的所有线程状态, 信息详细，但是是抓一个快照</li>
<li><code>jconsole</code>： 查看某个 Java 进程中线程的运行情况（图形界面）</li>
</ul>
<h3 id="3-线程运行原理"><a href="#3-线程运行原理" class="headerlink" title="3. 线程运行原理"></a>3. 线程运行原理</h3><h4 id="栈和栈帧"><a href="#栈和栈帧" class="headerlink" title="栈和栈帧"></a><strong>栈和栈帧</strong></h4><p>JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟机就会为其分配一块栈内存。</p>
<ul>
<li>每个栈由多个<strong>栈帧（Frame）</strong>组成，对应着每次<strong>方法调用</strong>时所占用的内存 </li>
<li>每个线程只能有一个<strong>活动栈帧</strong>，对应着当前<strong>正在执行的那个方法</strong></li>
</ul>
<h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a><strong>上下文切换</strong></h4><p>CPU 不执行当前线程，转向执行另一线程，叫做 上下文切换</p>
<blockquote>
<p>什么情况可能导致上下文切换呢？<br>(1) 线程的CPU时间片用完了<br>(2) 垃圾回收停顿用户线程<br>(3) 有更高优先级的线程要执行<br>(4) 线程自己调用了 sleep、yield、wait、join、part、synchronized、lock等方法</p>
</blockquote>
<p>上下文切换需要操作系统<strong>保存当前线程状态</strong>，并恢复另一线程的执行。对应着java中的概念就是程序计数器，它会记住下一条jvm指令的执行地址，是线程私有的。<br><strong>状态包括程序计数器，栈中每个栈帧的信息，包括局部变量表、操作栈、返回地址等</strong><br>所以，大量的线程切换会导致效率变低，影响性能</p>
<h3 id="4-常用方法"><a href="#4-常用方法" class="headerlink" title="4. 常用方法"></a>4. 常用方法</h3><p><strong>Thread.start()</strong><br>让线程进入就绪状态，但不一定运行（这取决于OS的任务调度器）。线程运行会执行自己的run方法。start只能用一次，否则会<code>IllegalThreadStateException</code>报错<br><strong>Thread.run()</strong><br>1.构造Thread对象时传入了Runnable任务对象，就执行任务对象的run方法<br>2.无参构造Thread对象，需要执行自己重写的run方法<br><strong>Thread.sleep(long n)</strong><br>1.当前线程休眠，<strong>让出cpu，但不放弃锁</strong>，从 <code>RUNNABLE</code> 进入 <code>TIMED_WAITING</code> 状态</p>
<p>2.其他线程可以使用 <code>interrupt</code> 方法打断正在睡眠的线程，这时 sleep 方法会抛出 <code>InterruptedException</code> </p>
<p>3.睡眠结束后的线程未必会立刻得到执行 </p>
<p>4.建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</p>
<p><strong>Thread.yield()</strong></p>
<p>1.当前线程让出cpu，从<code>Running</code>变为<code>Runnable</code>就绪态</p>
<p>2.具体是否执行取决于OS任务调度器</p>
<p><strong>Thread.interrupt()</strong></p>
<p>1.打断正常运行的线程</p>
<blockquote>
<p>会使打断标记变成真，利用打断标记可让程序自行决定被打断后是否继续执行</p>
</blockquote>
<p>2打断阻塞的线程（sleep、join、wait）</p>
<blockquote>
<p>打断后会使打断标记变为假</p>
</blockquote>
<h3 id="5-线程状态"><a href="#5-线程状态" class="headerlink" title="5. 线程状态"></a>5. 线程状态</h3><ul>
<li><p>&#x3D;&#x3D;操作系统角度&#x3D;&#x3D;</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221102202943166.png" alt="image-20221102202943166" style="zoom:67%;"></li>
</ul>
<blockquote>
<p><strong>【初始状态】</strong> 仅在语言层面创建java线程对象，没有和操作系统线程关联</p>
<p><strong>【可运行状态】</strong>线程已经和操作系统关联，可以由CPU调度执行</p>
<p><strong>【运行状态】</strong>CPU 正在运行的线程，如果时间片消耗完，或者调用 <code>yield</code>，会进入<strong>可运行状态</strong>，导致<strong>上下文切换</strong></p>
<p><strong>【阻塞状态】</strong>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入 【阻塞状态】</p>
<p>​					等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</p>
<p>​					与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑 调度它们</p>
<p><strong>【终止状态】</strong>表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</p>
</blockquote>
<ul>
<li><p>&#x3D;&#x3D;Java API角度&#x3D;&#x3D;</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221102203546452.png" alt="image-20221102203546452" style="zoom:67%;"></li>
</ul>
<h3 id="java-与协程"><a href="#java-与协程" class="headerlink" title="java 与协程"></a>java 与协程</h3><p>内核线程调度的成本主要来自于**&#x3D;&#x3D;用户态&#x3D;&#x3D;和&#x3D;&#x3D;核心态&#x3D;&#x3D;的状态转化<strong>，状态转化的开销主要来自于</strong>响应中段<strong>、</strong>保护和恢复现场现场**的成本。</p>
<p>由于最初多数的用户线程被设计成 协同式调度，所以被成为 协程。能完整地调用栈的恢复、保护工作的协程，称为”有栈协程“</p>
<p>协程的优势是轻量，但是需要在应用层面实现的内容特别多（调用栈、调度器等）</p>
<p>纤程是一种特殊的有栈协程，它的出现提供了一种新并发模型。一段使用纤程并发的代码会被分成两部分——执行过程和调度器。</p>
<h1 id="线程安全问题及其解决方法"><a href="#线程安全问题及其解决方法" class="headerlink" title="线程安全问题及其解决方法"></a>线程安全问题及其解决方法</h1><p>对于<strong>多个线程访问同一共享资源</strong>的情况，由于<strong>上下文切换</strong>有可能出现线程安全问题</p>
<p>比如 两个线程同时对共享变量i分别进行i++和i–操作，就可能出现</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221102190405037.png" alt="image-20221102190405037" style="zoom:50%;">

<blockquote>
<p>临界区：</p>
</blockquote>
<blockquote>
<p>一段代码块内如果存在对<strong>共享资源的多线程读写操作</strong>，那么这段代码块被称为临界区</p>
</blockquote>
<blockquote>
<p>竞态条件：</p>
</blockquote>
<blockquote>
<p>多个线程在临界区内执行，由于代码的执行序列不同导致结果无法预测，称为发生竞态条件</p>
</blockquote>
<p><strong>变量的线程安全分析</strong></p>
<p>1.静态变量、成员变量：有可能被共享</p>
<p>2.局部变量：</p>
<p>局部变量本身不可能被共享，但是不排除局部变量引用所指向的对象是共享变量</p>
<p><strong>常见的线程安全类：</strong></p>
<p>1.基本类型的包装类</p>
<p>2.String：不可变类，内部逻辑有final修饰</p>
<p>3.StringBuffer：不可变类</p>
<p>4.Random</p>
<p>5.Vector</p>
<p>6.Hashtable</p>
<p>7.JUC包下的类</p>
<p>注意：每个方法是原子的，但他们的组合不一定是原子的</p>
<h2 id="park-unpark"><a href="#park-unpark" class="headerlink" title="park &amp; unpark"></a>park &amp; unpark</h2><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//他们是 LockSupport 类中的方法</span></span><br><span class="line"><span class="comment">//暂停当前线程</span></span><br><span class="line">LockSupport.park();</span><br><span class="line"></span><br><span class="line"><span class="comment">//恢复某个线程的运行</span></span><br><span class="line">LockSupport.unpark(被暂停的线程对象)</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ul>
<li>先 unpark 再 park ，会导致线程暂停不住。park &amp; unpark 可以先 unpark，但是 wait &amp; notify 不能先 notify</li>
<li>wait &amp; notify 必须配合 Object Monitor 使用，而 park &amp; unpark 不必</li>
<li>park &amp; unpark 以线程为单位【阻塞】和【唤醒】一个线程，而 notify 只能随机唤醒一个线程，notifyAll 唤醒所有线程</li>
</ul>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h4><p>每个线程都有自己的 Paker 对象（底层 C++ 实现），由 _counter , _cond , _mutex 组成</p>
<ul>
<li>线程调用 Unsafe.park() 方法<ul>
<li>检查 _counter，如果 _ counter 为 0 <ul>
<li>获得 _mutex 互斥锁，进入 _cond 条件变量阻塞，并设置 _counter 为 0</li>
</ul>
</li>
<li>检查 _counter，如果 _counter 为 1 <ul>
<li>线程无需阻塞，继续运行，并设置 _counter 为 0</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107174542671.png" alt="image-20221107174542671" style="zoom:67%;">

<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107174748878.png" alt="image-20221107174748878" style="zoom:67%;">

<ul>
<li>线程调用 Unsafe.unpark(Thread-0) 方法，设置 _counter 为 1<ul>
<li>唤醒 _cond 条件变量中的 Thread-0</li>
<li>恢复线程运行</li>
<li>设置 _counter 为 0</li>
</ul>
</li>
</ul>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107175347986.png" alt="image-20221107175347986" style="zoom:67%;">

<h2 id="阻塞式悲观锁"><a href="#阻塞式悲观锁" class="headerlink" title="阻塞式悲观锁"></a>阻塞式悲观锁</h2><h3 id="synchroned"><a href="#synchroned" class="headerlink" title="synchroned"></a>synchroned</h3><p>利用对象锁保障了临界区内代码的原子性</p>
<p><strong>重量级锁Monitor</strong></p>
<p>首先，我们要了解一下对象头的结构</p>
<p>对于普通对象</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221102204314101.png" alt="image-20221102204314101" style="zoom:80%;">

<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221102204336250.png" alt="image-20221102204336250" style="zoom:80%;">

<p>每个java对象都关联一个Monitor对象，如果使用synchronized给对象上锁（重量级）后，，对象头的Mark Word就设置成了指向Monitor的指针，而它原来的内容则会在Monitor中暂存，解锁以后在归还给对象头</p>
<p><img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221102204815624.png" alt="image-20221102204815624"></p>
<ul>
<li><p>刚开始Monitor中的Owner为null</p>
</li>
<li><p>当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor中只能有一 个 Owner</p>
</li>
<li><p>在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入 EntryList BLOCKED</p>
</li>
<li><p>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争的时是非公平的</p>
</li>
<li><p>中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程</p>
</li>
<li><p>注意：</p>
<blockquote>
<p>synchronized必须是进入到同一个对象的monitor才有加锁效果</p>
<p>不加synchronized的对象不会关联监视器</p>
</blockquote>
</li>
</ul>
<p><strong>轻量级锁</strong></p>
<p>使用场景：一个对象虽然有多线程要加锁，但是加锁时间错开，可以用轻量级锁来优化</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221103190222699.png" alt="image-20221103190222699" style="zoom:80%;">

<ul>
<li><p>创建锁记录对象，给个线程栈帧中都包含一个锁记录结构，内部可以锁定对象的Mark Word</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221103190405232.png" alt="image-20221103190405232" style="zoom:80%;">
</li>
<li><p>让锁记录中Object reference指向锁对象，用cas替换object中的Mark Word，将Mark Word暂存到锁记录中</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221103190601922.png" alt="image-20221103190601922" style="zoom:80%;">
</li>
<li><p>cas替换成功，对象头存储了锁记录地址和状态00（标识轻量级锁）</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221103190733248.png" alt="image-20221103190733248" style="zoom:80%;">
</li>
<li><p>cas失败：</p>
<ul>
<li>其他线程已经持有改object的轻量级锁，发生锁竞争，锁膨胀为重量级锁</li>
<li>执行锁重入，就再添加一条Lock Record作为重入的计数<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221103191132502.png" alt="image-20221103191132502" style="zoom:80%;"></li>
</ul>
</li>
<li><p>解锁时</p>
<ul>
<li>如果有取值为null的锁记录，说明有锁重入，这时充值锁记录，表示重入计数-1</li>
<li>锁记录值不为null，使用cas将Mark Word的值恢复给对象头（失败的话说明锁已经膨胀，要进行重量级锁的解锁过程）</li>
</ul>
</li>
</ul>
<p>​	<strong>锁膨胀</strong></p>
<p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁，这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221103191919421.png" alt="image-20221103191919421" style="zoom:80%;">

<ul>
<li><p>Thead-1进行轻量级加锁时，Thread-0已经为对象加轻量级锁。此时进行锁膨胀</p>
<ul>
<li><p>为object申请Monitor锁，让object指向重量级锁地址</p>
</li>
<li><p>自己进入Monitor的EntryList，状态为BLOCKED</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221103192157312.png" alt="image-20221103192157312" style="zoom:80%;"></li>
</ul>
</li>
<li><p>Thread-0解锁时，用cas将Mark Word恢复给对象头，失败。进入重量级锁解锁流程，按照Monitor地址找到Monitor对象，设置Owner为null，唤醒EntryList中BLOCKED的线程</p>
<p><strong>自旋优化</strong></p>
<p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步 块，释放了锁），这时当前线程就可以避免阻塞</p>
<p>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势</p>
</li>
</ul>
<p><strong>偏向锁</strong></p>
<p>使用场景：轻量级锁再没有竞争时，每次重入都要执行cas操作，引入偏向锁作为优化，只有第一次使用 CAS 将线程ID设置到对象的Mark Word头，之后发现 这个线程ID是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有</p>
<p><strong>wait notify原理</strong></p>
<ul>
<li>Owner线程发现条件不满足，调用wait方法，即进入WaitSet变为WAITING状态，为阻塞状态，不占用时间片，并且会放弃锁</li>
<li>BLOCKED线程会在Owner线程释放时被唤醒</li>
<li>WAITING线程在Owner线程调用notify或notifyAll时被唤醒，但这不意味着立即获得锁，仍需进入EntryList重新竞争</li>
</ul>
<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>利用实现 Lock 接口的类实现锁，例如 ReentrantLock</p>
<p>特点：可中断、可设置超时时间、可设置为公平锁、支持多个条件变量、可重入</p>
<p><strong>死锁问题</strong></p>
<ul>
<li><p>解决方法</p>
<ul>
<li>线程申请资源时，一次性得请求他所需要的所有资源。若无法满足则不能执行。</li>
<li>进程在申请新的资源时，释放已占有的资源。后面若还需要它们，则需要重新申请。</li>
<li>将系统中的资源顺序编号，规定进程只能依次申请资源。</li>
</ul>
</li>
<li><p>死锁 和 阻塞 的区别</p>
<ul>
<li>阻塞是由于资源不足引起的排队等待的现象</li>
<li>死锁是至少两个对象相互持有对方所需要的资源，而都在等待对方释放资源</li>
</ul>
</li>
<li><p><strong>避免</strong>死锁著名算法</p>
<ul>
<li>银行家算法，动态检测资源分配，确保“循环等待”条件永远不成立</li>
<li>每个进程事先预报需要的最大资源，算法确保系统处于 safety 状态</li>
</ul>
<blockquote>
<p>预防死锁要破坏四个必要条件，代价大，不可行</p>
</blockquote>
</li>
</ul>
<h3 id="Java-内存模型（-JMM-）"><a href="#Java-内存模型（-JMM-）" class="headerlink" title="Java 内存模型（ JMM ）"></a>Java 内存模型（ JMM ）</h3><p>JMM 用来屏蔽各种硬件和操作系统的内存访问差异，以实现让 java 程序在各种平台下都能达到一致的内存访问效果</p>
<p>JMM 定义了主存、工作内存抽象概念，底层对应着CPU寄存器、缓存、硬件内存、CPU指令优化等</p>
<p>JMM 的主要目的是定义程序中各种共享变量的访问规则，即关注在虚拟机中把变量的值存储到工作内存和从工作内存中取出变量这样的底层细节</p>
<blockquote>
<p>注意：</p>
<p>这里的共享变量包括 实例字段、静态字段、数组对象的元素</p>
<p>不包括 方法参数、局部变量，因为它们是线程私有，不存在共享问题</p>
</blockquote>
<p>内存间的交互操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>含义</th>
<th>作用范围</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>lock</td>
<td>锁定</td>
<td>主内存</td>
<td>把一个变量标识为一条线程独占的状态</td>
</tr>
<tr>
<td>unlock</td>
<td>解锁</td>
<td>主内存</td>
<td>把一个处于锁定状态的变量释放出来</td>
</tr>
<tr>
<td>&#x3D;&#x3D;read&#x3D;&#x3D;</td>
<td>读取</td>
<td>主内存</td>
<td>把变量的值从主存传输到工作内存中，以便随后的 load 使用</td>
</tr>
<tr>
<td>&#x3D;&#x3D;load&#x3D;&#x3D;</td>
<td>载入</td>
<td>工作内存</td>
<td>把 read 操作从主存得到的变量值放到工作内存的变量副本中</td>
</tr>
<tr>
<td>use</td>
<td>使用</td>
<td>工作内存</td>
<td>把工作内存的变量值传给执行引擎，对应需要使用变量的值的字节码指令</td>
</tr>
<tr>
<td>assign</td>
<td>赋值</td>
<td>工作内存</td>
<td>把执行引擎接收到值赋给工作内存的变量，对应给变量赋值的字节码指令</td>
</tr>
<tr>
<td>store</td>
<td>存储</td>
<td>工作内存</td>
<td>把工作内存变量值传给主存，以供后续 write 使用</td>
</tr>
<tr>
<td>write</td>
<td>写入</td>
<td>主内存</td>
<td>把 store 操作从工作内存中得到的变量值放到主内存的变量中</td>
</tr>
</tbody></table>
<blockquote>
<p>把变量从 主内存 拷贝到 工作内存 中，按顺序执行 read、load 操作</p>
<p>把变量从 工作内存 拷贝到 主内存 中，按顺序执行 store、write 操作</p>
<p>只要求按顺序执行，不要求连续执行</p>
</blockquote>
<p>JMM体现在以下几个方面：</p>
<blockquote>
<p>原子性：指令不受上下文切换的影响</p>
<p>可见性：指令不受cpu缓存的影响，一个指令对主存数据的修改，对另一个线程可见</p>
<p>有序性：指令不受cpu指令并行优化的影响</p>
</blockquote>
<p><strong>可见性</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptrdException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span>(run) &#123;</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    run = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现象：main 线程对 run 的修改对 t 线程不可见，t 无法停止</p>
<p>原因：</p>
<p>​	1.初始状态，t 线程从主存读取 run 值到工作内存</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221105141156908.png" alt="image-20221105141156908" style="zoom: 69%;">



<p>​	2.因为 t 线程要频繁从主存读取 run 值，JIT 编译器会将 run 值缓存到自己的工作内存的高速缓存中，减少对主存的访问，提高效率</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221105141411364.png" alt="image-20221105141411364" style="zoom:65%;">

<ol start="3">
<li><p>1 秒后，main线程修改了 run 值，并同步到主存，而 t 从自己的工作内存读取变量，结果永远是旧值</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221105141644115.png" alt="image-20221105141644115" style="zoom:67%;"></li>
</ol>
<p><strong>解决方法</strong></p>
<p>volatile 修饰成员变量和静态成员变量，避免线程从工作缓存中查找变量值，必须从主线程获取</p>
<blockquote>
<p><strong>注意</strong> synchronized 可保证原子性、可见性，但是属于重量级操作，性能低</p>
<p>System.out.println() 也会保证读取变量在主存中读取</p>
</blockquote>
<p><strong>有序性</strong></p>
<p>JVM在不影响正确性的前提下，会调整语句的执行顺序，其内在原理是CPU的指令重排序优化。</p>
<blockquote>
<p>每条指令可分为 取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回 5 个阶段，这些指令的各个阶段可通过<strong>重排序</strong>和<strong>组合</strong>实现<strong>指令级并行</strong>。现代CPU支持多条指令流水线，并不能缩短单条指令执行时间，却提高了指令的吞吐率</p>
</blockquote>
<p><strong>内存屏障</strong></p>
<ul>
<li><p>可见性</p>
<ul>
<li>写屏障 保障该屏障之前的，对共享变量的改动，都同步到主存中</li>
<li>读屏障 保障该屏障之后的，对共享变量的读取，加载的是主存中的最新数据</li>
</ul>
</li>
<li><p>有序性</p>
<ul>
<li>写屏障 保障该屏障之前的代码，在指令重排时，不会排在写屏障之后</li>
<li>读屏障 保障该屏障之后的代码，在指令重排时，不会排在读屏障之前</li>
</ul>
</li>
</ul>
<p><strong>volatile 原理</strong></p>
<ul>
<li>volatile 变量在各个线程的工作内存中不存在一致性问题，保证可见性</li>
</ul>
<p>底层使用内存屏障（Memory Barrier）：</p>
<ul>
<li>对 volatile 变量的写指令后加入写屏障</li>
<li>对 volatile 变量的读指令前加入读屏障</li>
</ul>
<p><strong>double-checked locking问题</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singletion</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singletion</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singletion <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123; <span class="comment">//双重锁，使得只有第一次调用才需要进入同步块创建实例，高效</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123; <span class="comment">//也许有其他线程已经创建实例，所以再判断一次</span></span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singletion</span>();</span><br><span class="line">                        <span class="comment">//保证先invokespecial（调用构造方法），再 putstatic（给INSTANCE赋值）</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<blockquote>
<ol>
<li>懒惰初始化</li>
<li>首次使用 getInstance（）才需要加锁，后续使用无需加锁</li>
<li>volatile 使得 给INSTANCE 赋值之前的代码 调用构造方法 按顺序执行</li>
</ol>
</blockquote>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221105163706708.png" alt="image-20221105163706708" style="zoom:50%;">

<p><strong>happens-before</strong></p>
<p>总结了一个线程对共享变量的写，对其他线程的读可见的 7 种情况</p>
<blockquote>
<ol>
<li>线程对一个锁对象解锁前对变量的写操作，对于接下来对同一个锁对象加锁的线程而言，该变量可见</li>
<li>线程对 violate 变量的写，对其他线程对变量的读可见</li>
<li>线程 start 对变量的写，对线程开始后对变量的读可见</li>
<li>线程结束后对变量的写，对其他线程得知它结束后的读可见(t.isAlive或t.join)</li>
<li>线程 t1 打断 t2 (interrupt) 前对变量的写，对于其他线程得知 t2 被打断后对该变量的读可见（t2.isInterrupted）</li>
<li>对变量默认值（0，false，null）的写，对其它线程对该变量的读可见</li>
<li>具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z</li>
</ol>
</blockquote>
<h2 id="CAS-非阻塞方式"><a href="#CAS-非阻塞方式" class="headerlink" title="CAS 非阻塞方式"></a>CAS 非阻塞方式</h2><p>cas可以实现无锁方式，利用失败重试的方式，保证共享变量的线程安全</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AccountSafe</span> <span class="keyword">implements</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger balance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略其他代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> balance.get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> prev - amount;</span><br><span class="line">            <span class="comment">//comapreAndSet 做检查，set前，先比较prev 与当前值是否一致</span></span><br><span class="line">            <span class="comment">//一致，修改成功，返回 true</span></span><br><span class="line">            <span class="comment">//不一致，失败重试</span></span><br><span class="line">            <span class="keyword">if</span>(balance.compareAndSet(prev, next)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221106192113983.png" alt="image-20221106192113983" style="zoom:67%;">

<blockquote>
<p>CAS底层是 lock cmpxchg 指令（X86架构），在单核 CPU 和多核 CPU 下保障【比较-交换】操作的原子性</p>
<ul>
<li>多核状态下，某个核执行到带 lock 的指令，CPU 会让总线锁住，直至指令执行完毕。</li>
</ul>
</blockquote>
<p><strong>volatile</strong></p>
<p>volatile 修饰共享变量，使得线程避免从工作内存中查找变量的值，而是必须到主存中获取，保证一个线程对 volatile 变量的修改，对另一个线程可见</p>
<p>&#x3D;&#x3D;CAS 必须借助 volatile 才能读取到共享变量的新值并实现【比较并交换】效果&#x3D;&#x3D; </p>
<p><strong>CAS 特点总结</strong></p>
<ul>
<li><p>无锁效率高</p>
<ul>
<li>无锁状态下，即使重试失败，线程也在高速运行，不会发生上下文切换，节省了保存现场、恢复现场等时间。而 synchronized 会让线程没有获得锁的时候发生阻塞</li>
<li>注意：适用于线程数少，CPU 核心数多的情况</li>
</ul>
</li>
<li><p>基于乐观锁思想</p>
<ul>
<li>最乐观的估计，认为自己能获得锁，采用失败重试的方法</li>
</ul>
</li>
</ul>
<h3 id="CAS-相关-API"><a href="#CAS-相关-API" class="headerlink" title="CAS 相关 API"></a>CAS 相关 API</h3><p><strong>原子整数</strong></p>
<ul>
<li>AtomicBoolean</li>
<li>AtomicLong</li>
<li>AtomicInteger</li>
</ul>
<p><strong>原子引用</strong></p>
<ul>
<li>AtomicReference</li>
<li>AtomicMarkableReference</li>
<li>AtomicStampedReference</li>
</ul>
<p><strong>原子数组</strong></p>
<ul>
<li>AtomicIntegerArray</li>
<li>AtomicLongArray</li>
<li>AtomicReferenceArray</li>
</ul>
<p><strong>字段更新器</strong></p>
<ul>
<li><p>AtomicIntegerFieldUpdater</p>
</li>
<li><p>AtomicLongFieldUpdater</p>
</li>
<li><p>AtomicReferenceFieldUpdater</p>
<blockquote>
<p>注意：</p>
<p>字段更新器只能对 volatile 修饰的字段使用！</p>
</blockquote>
</li>
</ul>
<p><strong>原子累加器</strong></p>
<ul>
<li><p>LongAdder 比 AtomicLong 高效</p>
<blockquote>
<p>LongAdder 在有竞争的时候，设置多个累加单元，不同的线程在不同的累加单元上工作，最后再将结果汇总。这样线程们在累加时操作不同的 cell 变量，减少 CAS 失败重试，提高性能</p>
</blockquote>
</li>
<li><p>LongAdder 类的几个关键域</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//累加单元数组，懒惰初始化</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基础值，若没有竞争，则用 cas 累加这个域</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> base;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在 cells 创建或扩容时，设置为 1 ，表示加锁</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> cellsBusy;</span><br></pre></td></tr></table></figure>

<ul>
<li>Cell 累加单元</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//防止缓存行伪共享</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Cell</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> value;</span><br><span class="line">    Cell(<span class="type">long</span> x) &#123; value = x; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//cas 方式累加</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">cas</span><span class="params">(<span class="type">long</span> prev, <span class="type">long</span> next)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="built_in">this</span>, valueOffset, prev, next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//other codes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 CPU 与内存的速度差异很大，所以设置缓存预读数据来提高效率。缓存以缓存行（64 byte）为单位。</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221106202418512.png" alt="image-20221106202418512" style="zoom:67%;">

<p>缓存的加入会造成数据副本的产生，同一份数据存储在不同核心的缓存行中。为保证数据一致性，如果某个 CPU 核心更改数据，其他 CPU 核心对应的缓存行必须失效</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221106203849311.png" alt="image-20221106203849311" style="zoom:67%;">

<p>因为 Cell 是数组形式，内存中连续存放。同一数据存储在不同 CPU 的缓存行里，任何线程对数据的修改都会造成对方缓存行的失效</p>
<p>@sun.misc.Contended 原理是使用注解的对象或字段，前后各增加 128 byte 的 padding ，让 CPU 将对象预读至缓存时占用不同的缓存行，这样，不会造成对方缓存行的失效</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221106204350338.png" alt="image-20221106204350338" style="zoom:67%;">

<p><strong>LongAdder 累加执行流程</strong></p>
<ol>
<li>进入 add</li>
</ol>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221106210238709.png" alt="image-20221106210238709" style="zoom:80%;">

<ol start="2">
<li>进入 longAccumulate</li>
</ol>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221106210420237.png" alt="image-20221106210420237" style="zoom:80%;">

<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221106235240490.png" alt="image-20221106235240490" style="zoom:80%;">

<p>​	每个线程刚进入 longAccumulate 时，会尝试对应一个 cell 对象（找到一个坑位）</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221106235334469.png" alt="image-20221106235334469" style="zoom:80%;">

<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="ThreadPoolExecuter"><a href="#ThreadPoolExecuter" class="headerlink" title="ThreadPoolExecuter"></a>ThreadPoolExecuter</h2><h6 id><a href="#" class="headerlink" title></a><img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107011107666.png" alt="image-20221107011107666" style="zoom:60%;"></h6><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a><strong>构造方法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,        //核心线程数              </span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,		//最大线程数	</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,		//救急线程存活时间</span></span><br><span class="line"><span class="params">                          TimeUnit unit,			//救急线程时间单位</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,   //阻塞队列</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,		//线程工厂-为线程起个好名字</span></span><br><span class="line"><span class="params">                          RejectionExecutionHandler handler)</span>;  <span class="comment">//拒绝策略</span></span><br></pre></td></tr></table></figure>

<ul>
<li>&#x3D;&#x3D;**核心线程 **和 <strong>救急线程</strong> 的区别&#x3D;&#x3D;<ul>
<li>创造条件不同：<ul>
<li>有新任务需要执行，只要核心线程数没有达到 corePoolSize，就会创建</li>
<li>救急线程需要在<strong>阻塞队列已满</strong>，并且 <code>maximumPoolSize - corePoolSize</code> 还有容量的情况下，有了新任务才会创建救急线程</li>
</ul>
</li>
<li>生存时间不同：<ul>
<li>核心线程<strong>一旦创建就一直存活</strong>，除非任务执行异常，任务和线程可能”同归于尽“</li>
<li>救急线程不会一直存活，空闲状态超过 <code>keepAliveTime</code> 就会灭亡</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a><strong>工作流程</strong></h3><p><strong>（1）</strong>线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会<strong>创建一个新线程来执行任务</strong></p>
<p><strong>（2）</strong>当线程数达到 <code>corePoolSize</code> 并没有空闲线程，这时再加入任务，<strong>新的任务会加入 <code>workQueue</code> 队列排队</strong>，直至有空闲线程</p>
<p><strong>（3）</strong>如果队列选择有界队列，当任务数超过队列大小，会<strong>创建 <code>maximumPoolSize - corePoolSize</code> 数目的救急线程</strong></p>
<p><strong>（4）</strong>如果线程达到 <code>maximumPoolSize</code> 仍然有新任务加入，会<strong>执行拒绝策略</strong>。</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107134143690.png" alt="image-20221107134143690" style="zoom:80%;">

<p><strong>（5）</strong>高峰期后，救急线程如果空闲，等待一段时间后会自动结束（时间由 <code>keepAliveTime</code> 控制）</p>
<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a><strong>工厂方法</strong></h3><h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a><strong>newFixedThreadPool</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThread)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThread, nThread,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MillSECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;特点：&#x3D;&#x3D;</p>
<ul>
<li>核心线程数 &#x3D; 最大线程数（<strong>无救急线程</strong>）</li>
<li>阻塞队列<strong>无界</strong></li>
</ul>
<p>&#x3D;&#x3D;应用场景：&#x3D;&#x3D;</p>
<ul>
<li>任务量已知，相对耗时</li>
</ul>
<h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a><strong>newCachedThreadPool</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;特点：&#x3D;&#x3D;</p>
<ul>
<li>没有核心线程，<strong>全是救急线程</strong>，救急线程可以<strong>无限创建</strong>，空闲生存时间为<strong>60 秒</strong></li>
<li><code>SynchronousQueue</code> 队列特点，没有容量，没有线程来取放不进去</li>
</ul>
<p>应用场景：</p>
<ul>
<li>任务数密集，执行时间较短</li>
</ul>
<h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a><strong>newSingleThreadExecutor</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        						<span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用场景：</p>
<ul>
<li>希望多个线程排队执行，<strong>线程数固定为 1</strong>，任务数多于 1时，会放入无界队列。任务执行完毕，这唯一的线程也不会释放</li>
</ul>
<p>区别：</p>
<ul>
<li>自己创建一个单线程串行执行任务，如果任务执行失败而终止，则没有任何补救措施。而线程池会新建一个线程，保障线程池的正常工作</li>
<li><code>Executors.newSingleThreadExecutor()</code>线程数始终为 1，不能修改<ul>
<li><code>FinalizableDelegatedExecutorService</code> 应用的是装饰器模式，只暴露了 <code>ExecutorService</code> 接口，因此不能调用 <code>ThreadPoolExecutor</code> 中的特有方法</li>
</ul>
</li>
</ul>
<h3 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a><strong>提交任务</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行无返回值任务</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行有返回值任务，用 Future 获得结果</span></span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行一个任务集合</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line">    	<span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? entends Callable&lt;T&gt;&gt; tasks, </span></span><br><span class="line"><span class="params">                             	<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">    	<span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">//执行一个任务集合，返回最先执行完成的任务，并取消其他所有任务</span></span><br><span class="line">&lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line">    	<span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params">                <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">    	<span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>

<h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a><strong>关闭线程池</strong></h3><p><strong>shutdown</strong></p>
<ul>
<li>线程池状态变成 SHUTODOWM<ul>
<li>不会接受新任务</li>
<li>已提交任务会执行完</li>
<li>不会阻塞调用线程的执行</li>
</ul>
</li>
</ul>
<p><strong>shutdownNow</strong></p>
<ul>
<li>线程池状态变为 STOP<ul>
<li>不会接受新任务</li>
<li>队列中的任务也停止</li>
<li>用 interrupt 的方法中断正在执行的任务</li>
</ul>
</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h3><ul>
<li>降低资源消耗<ul>
<li><strong>重复利用</strong>已经创建的线程，避免线程反复创建、销毁带来的损耗</li>
</ul>
</li>
<li>提高响应速度<ul>
<li>任务到达时，不需要等待线程创建就能立即执行</li>
</ul>
</li>
<li>提高线程可管理性<ul>
<li>线程控制在一定数量，避免线程过多不合理消耗资源，甚至OOM使用线程池统一分配、调优、监控</li>
</ul>
</li>
<li>封装过程<ul>
<li>Executor 框架把任务的提交和执行进行解耦，只要定义好任务，提交到线程池，不用关心任务是如何执行，被哪个线程执行，什么时候执行</li>
</ul>
</li>
</ul>
<h1 id="AQS-原理"><a href="#AQS-原理" class="headerlink" title="AQS 原理"></a>AQS 原理</h1><p>AQS 是 JUC 包中非常核心的抽象类，全程 <code>AbstractQueuedSynchronizer</code>，它为多线程访问共享资源提供了一个队列同步器，是阻塞式锁和相关同步器工具的框架。</p>
<p>在 JUC 包下，很多组件都依赖 AQS 实现线程的同步和唤醒，如 Lock、Semaphore、CountDownLatch 等等</p>
<h2 id="三个核心组成部分"><a href="#三个核心组成部分" class="headerlink" title="三个核心组成部分"></a><strong>三个核心组成部分</strong></h2><ul>
<li><code>volatile</code> 修饰的 <code>state</code> 变量，作为锁的标志。<ul>
<li><code>getState</code> - 获取 state 状态</li>
<li><code>setState</code> - 设置 state 状态</li>
<li><code>compareAndSetState</code> - cas 设置 state 状态，失败重试到一定次数需要进阻塞队列，因为 AQS 实现的是阻塞锁</li>
</ul>
</li>
<li>双向链表维护的 FIFO 线程等待队列，类似于 Monitor 的 EntryList （区别是Monitor是 C++ 实现）</li>
<li>条件变量实现等待、唤醒线程，支持多个条件变量，类似 Monitor 的WaitSet（区别是 Monitor 的 WaitSet 只有一个）</li>
</ul>
<h2 id="资源共享方式："><a href="#资源共享方式：" class="headerlink" title="资源共享方式："></a><strong>资源共享方式</strong>：</h2><ul>
<li>独占模式<ul>
<li>同一时刻只有一个线程能获取竞态资源，如 <code>ReentrantLock</code></li>
</ul>
</li>
<li>共享模式<ul>
<li>同一时刻，多个线程可以同时获得竞态资源，如 <code>CountDownLatch</code>、<code>Semaphore</code></li>
</ul>
</li>
</ul>
<h2 id="自定义锁"><a href="#自定义锁" class="headerlink" title="自定义锁"></a><strong>自定义锁</strong></h2><ul>
<li><p>集成 AQS，自定义多线程竞争的实现逻辑。子类需要定义如何维护 state 状态，控制如何获取锁和释放锁</p>
<blockquote>
<p>子类要实现的方法：</p>
<p><code>tryAcquire</code> <code>tryRelease</code> <code>tryAcquireShared</code> <code>tryReleaseShared</code> <code>isHeldExclusively</code></p>
</blockquote>
</li>
<li><p>获取锁</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if try acquire lock fail</span></span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg)) &#123;</span><br><span class="line">    <span class="comment">// thread into queue,be blocked by park</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>释放锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if try release lock success</span></span><br><span class="line"><span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">    <span class="comment">// awake blocking queue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="ReentrantLock原理"><a href="#ReentrantLock原理" class="headerlink" title="ReentrantLock原理"></a>ReentrantLock原理</h2><img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107191313559.png" alt="image-20221107191313559" style="zoom:67%;">

<h4 id="加锁流程"><a href="#加锁流程" class="headerlink" title="加锁流程"></a><strong>加锁流程</strong></h4><ul>
<li>没有竞争时</li>
</ul>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107191501964.png" alt="image-20221107191501964" style="zoom:67%;">

<ul>
<li>第一个竞争出现时，Thread-1 执行了<ul>
<li>CAS 尝试把 state 由 0 改成 1，结果失败</li>
<li>进入 tryAcquire 逻辑，这时 state 还是 1，依然失败</li>
<li>进入 addWaiter 逻辑，构造 Node 队列</li>
</ul>
</li>
</ul>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107191917280.png" alt="image-20221107191917280" style="zoom:67%;">

<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107191932742.png" alt="image-20221107191932742" style="zoom:67%;">

<ul>
<li>当前线程进入 acquireQueued 逻辑<ul>
<li>acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞</li>
<li>如果自己是紧邻着 head，那么再次 tryAcquire 尝试获取锁，这时 state 仍为 1，失败</li>
<li>进入 shouldParkAfterFailedAcquire 逻辑，将前驱 node，即 head 的 waitStatus 改为 -1，返回 false</li>
<li>shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，这时 state 仍为 1，失败</li>
<li>再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回 true</li>
<li>进入 parkAndCheckInterrupt</li>
</ul>
</li>
</ul>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107192255935.png" alt="image-20221107192255935" style="zoom:67%;">

<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107192310701.png" alt="image-20221107192310701" style="zoom:67%;">

<h4 id="解锁过程"><a href="#解锁过程" class="headerlink" title="解锁过程"></a><strong>解锁过程</strong></h4><img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107192423295.png" alt="image-20221107192423295" style="zoom:67%;">

<ul>
<li>Thread-0 释放锁，进入 tryRelease 流程，如果成功<ul>
<li>设置 exclusiveOwnerThread 为 null</li>
<li>state &#x3D; 0 （注意这里顺序不能改变，因为 setState 逻辑中有volatile，写屏障保证 exclusiveOwnerThread 的修改也具有可见性）</li>
</ul>
</li>
</ul>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107192748256.png" alt="image-20221107192748256" style="zoom:67%;">

<ul>
<li>当前队列不为 null，并且 head 的 waitStatus &#x3D; -1，进入 unparkSuccessor 流程</li>
<li>找到队列中离 head 最近的一个 Node，unpark 恢复其运行</li>
<li>回到 Thread-1 的 acquireQueued 流程</li>
</ul>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107192906130.png" alt="image-20221107192906130" style="zoom:67%;">

<ul>
<li><p>如果加锁成功</p>
<ul>
<li>exclusiveOwnerThread 为 Thread-1，state &#x3D; 1</li>
<li>head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread</li>
<li>原本的 head 因为从链表断开，而可被垃圾回收</li>
</ul>
</li>
<li><p>如果加锁不成功</p>
<ul>
<li>Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞</li>
</ul>
</li>
</ul>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107193047838.png" alt="image-20221107193047838" style="zoom:67%;">

<h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><p>当读操作远远多于写操作时，使用【读写锁】让【读读并发】，提高性能。读-写、写-写 依然互斥</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataContainer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">rw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">r</span> <span class="operator">=</span> rw.readLock();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">w</span> <span class="operator">=</span> rw.writeLock();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	<span class="comment">//do something    </span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<ul>
<li>读锁不支持条件变量</li>
<li>重入时升级不支持：一个线程在持有读锁的情况下去获取写锁，会导致锁的永久等待</li>
<li>重入时降级支持：一个线程持有写锁的情况下可以获取读锁</li>
</ul>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p><strong>基本使用</strong></p>
<p>信号量，限制能同时访问共享资源的线程上限</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//创建对象</span></span><br><span class="line">    <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//获取许可</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                semaphore.acquire();  <span class="comment">//没有获取许可的线程在此阻塞</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//code need to restrict number of threads-concurrent</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//释放许可</span></span><br><span class="line">                samephore.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原理</strong></p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107194337764.png" alt="image-20221107194337764" style="zoom:67%;">

<ul>
<li>三个线程 cas 竞争成功，两个线程 cas 竞争失败，进入 AQS 队列 park 阻塞</li>
</ul>
<p><img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107194620961.png" alt="image-20221107194620961"></p>
<ul>
<li>一个线程 4 释放了自己的 permits， state + 1</li>
</ul>
<p><img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107194728979.png" alt="image-20221107194728979"></p>
<ul>
<li>另一个阻塞线程 0 竞争成功，设置自己为 head 节点，断开原来的 head 节点， unpark 接下来的线程 3 节点。但是由于没有许可，所以线程 3 在尝试不成功后进入 park 阻塞</li>
</ul>
<p><img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107195112371.png" alt="image-20221107195112371"></p>
<p><strong>优点</strong></p>
<ul>
<li>与通过 控制线程数来控制并发度 的方法相比，通过 Semaphore 控制并发数可以控制的更加细粒度，因为真正需要有并发数限制的代码只需要放在 acquire 和 release 之间，其他仍可以由更多线程执行</li>
</ul>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>用来进行线程同步协作，等待所有线程完成倒计时。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> staric <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedExecption &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;);</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;);</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;);</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            latch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么不用 join，也能达到当前线程等待其他线程运行结束后在开始运行。</p>
<p>原因：Thread.join  如果用线程池的话，一个线程可能一直不会结束，就一直等待。</p>
</blockquote>
<p>应用：同步等待多个线程调用结束，可以用 Future 接收线程调用结果</p>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>循环栅栏，与 CountDownLatch 类似，同样用于线程协作。多个线程在屏障前等待，直到所有线程都到达这个屏障时，再一起执行后面的动作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CyclicBarrier</span> <span class="variable">cb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">2</span>, () -&gt; &#123;</span><br><span class="line">    <span class="comment">//do something after all threads break the barrier</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//do sothing</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.await();  <span class="comment">//线程数不足，阻塞等待</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(<span class="comment">//come code) &#123;</span></span><br><span class="line">        <span class="comment">// othercode</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//do sothing</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.await();  <span class="comment">//足够，开始运行</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(<span class="comment">//come code) &#123;</span></span><br><span class="line">        <span class="comment">// othercode</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong> CyclicBarrier 和 CountDownLatch 区别在于</p>
<ul>
<li><p>CyclicBarrier 线程遇到 await 都会阻塞，然后一起返回；CountDownLatch 遇到 CountDown 不会阻塞，遇到 await 会阻塞</p>
</li>
<li><p>CyclicBarrier 可重用，类似【人满发车】；CountDownLatch 计数一旦指定，不可修改为指定值，不能重用,用完了要重新初始化一个</p>
</li>
</ul>
</blockquote>
<h1 id="线程安全集合类"><a href="#线程安全集合类" class="headerlink" title="线程安全集合类"></a>线程安全集合类</h1><p><strong>补充：Java 集合类</strong></p>
<p>Java 集合类是对于数据结构的实现，所有类位于 java.util 包下，由两个接口派生出来，包括：</p>
<ul>
<li>Collection<ul>
<li>List<ul>
<li>ArrayList</li>
<li>LinkedList</li>
</ul>
</li>
<li>Set<ul>
<li>HashSet</li>
<li>TreeSet</li>
<li>LinkedHashSet</li>
</ul>
</li>
</ul>
</li>
<li>Map<ul>
<li><ul>
<li>HashMap</li>
<li>TreeMap</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>线程安全集合类</strong></p>
<p><img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221108155306063.png" alt="image-20221108155306063"></p>
<p>线程安全集合类分类</p>
<ul>
<li>遗留类</li>
<li>Collections 装饰类</li>
<li>JUC 类<ul>
<li>Blocking 大部分实现基于锁，阻塞方式</li>
<li>CopyOnWrite 类容器修改开销大</li>
<li>Concurrent 类容器<ul>
<li>内部多使用 cas 优化，吞吐量高</li>
<li>弱一致性<ul>
<li>遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍 历，这时内容是旧的</li>
<li>求大小弱一致性，size 操作未必是 100% 准确</li>
<li>读取弱一致性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>遍历时如果发生修改，对于非安全容器，使用 fail-fast 机制让遍历立即失败，抛出 ConcurrentModificationException</p>
</blockquote>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p><strong>补充：普通 HashMap</strong></p>
<blockquote>
<p> hash code</p>
</blockquote>
<blockquote>
<ul>
<li>hash 函数实现一种算法，通过该算法得到一个 hashcode，并放置在 hash table 中的对应位置</li>
<li>每个对象都有 hashcode，hashcode 代表对象在hash table 中的位置</li>
<li>hashcode 的存在主要为了查找的快捷性，先通过 hashcode 比较，再用 equals 方法比较两个对象是否相等</li>
<li>如果两个对象 equals 相等，那么这两个对象的 HashCode 一定相同</li>
<li>如果两个对象的 HashCode 相同，不代表两个对象就相同，只能说明两个对象在散列存储结构中存在了同一个桶下标上</li>
<li>equals 方法重写，建议 hashcode 也一起重写。这是为了保证两个 equals 相等的对象 hashcode也相等</li>
</ul>
</blockquote>
<ul>
<li><p>HashMap</p>
<ul>
<li><p>HashMap 是最常用的集合类框架，数据结构为 数组 + 链表或红黑树</p>
</li>
<li><pre><code class="java">static class Node&lt;K, V&gt; implements Map.Entry&lt;K, V&gt; &#123;
    final int hash;
    final K key;
    V value;
    Node&lt;K, V&gt; next;
&#125;
//Node 是内部类
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 存储元素过程</span><br><span class="line"></span><br><span class="line">    - 计算键的 hashcode ，定位到桶下标</span><br><span class="line">    - 如果没有元素，直接插入</span><br><span class="line">    - 如果有元素，判断是否 equal </span><br><span class="line"></span><br><span class="line">  - 参数</span><br><span class="line"></span><br><span class="line">    - 初始容量大小：默认16</span><br><span class="line">    - 加载因子：默认0.75f。超过会扩容</span><br><span class="line"></span><br><span class="line">  - 版本区别</span><br><span class="line"></span><br><span class="line">    - jdk1.7 位桶 + 链表</span><br><span class="line">    - jdk1.8 位桶 + 链表/红黑树：链表长度大于8且节点数组长度大于64的时候，就把链表下所有的节点转为红黑树，否则继续采用扩容策略</span><br><span class="line"></span><br><span class="line">- 线程安全问题——扩容死链</span><br><span class="line"></span><br><span class="line">  - jdk1.7 多线程同时对一个 HashMap 扩容的过程中，由于要将原表中的结点移植到新表的桶下标中，在形成链表的过程中可能有死链的情况</span><br><span class="line">  - jdk 1.8 调整扩容算法，新链表的形成采用尾插法，不会造成死链，但可能出现丢失数据等线程安全问题</span><br><span class="line"></span><br><span class="line">**线程安全的 HashMap**</span><br><span class="line"></span><br><span class="line">**jdk 7**</span><br><span class="line"></span><br><span class="line">由许多（2 的 N 次方个） Segment 组合而成一个 segments 数组，每个 Segment 可看作一个 HashMap 对象，包含一个 HashEntry 数组，数组中每个 HashEntry 既是一个键值对，又是一个链表的头节点</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;Java并发编程/image-20221111180122508.png&quot; alt=&quot;image-20221111180122508&quot; style=&quot;zoom:67%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;Java并发编程/image-20221111180138608.png&quot; alt=&quot;image-20221111180138608&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">put 操作流程</span><br><span class="line"></span><br><span class="line">- 通过 key 定位到 Segment，在对应的 Segment 中进行具体的 put</span><br><span class="line">- 尝试获得锁，获取失败则执行`scanAndLockForPut()`自旋获得锁，重试次数超过`MAX_SCAN_RETRIES`则改为阻塞锁获取</span><br><span class="line">- 加锁后遍历该 HashEntry，为空需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容，不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value（默认`onlyIfAbsent`为false）</span><br><span class="line">- 释放锁</span><br><span class="line"></span><br><span class="line">**jdk8**</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;Java并发编程/image-20221111181520062.png&quot; alt=&quot;image-20221111181520062&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">put 操作流程</span><br><span class="line"></span><br><span class="line">- 根据 key 计算出 hashcode，然后开始遍历 table</span><br><span class="line">- 判断是否需要初始化</span><br><span class="line">- f 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功</span><br><span class="line">- 如果当前位置的 hashcode == MOVED == -1,则需要进行扩容</span><br><span class="line">- 如果都不满足，则利用 synchronized 锁写入数据</span><br><span class="line">- 如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树</span><br><span class="line"></span><br><span class="line">## LinkedBlockingQueue</span><br><span class="line"></span><br><span class="line">**入队、出队流程**</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class LinkedBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;</span><br><span class="line">    	implements BlockingQueue&lt;E&gt;, java.io.Serializable &#123;</span><br><span class="line">    static class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        /**</span><br><span class="line">         * 1.next 是真正的后继节点</span><br><span class="line">         * 2.next 是自己，表示出队</span><br><span class="line">         * 3.next 是null，没有后继节点</span><br><span class="line">         */</span><br><span class="line">        Node(E x) &#123;item = x;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>初始化链表 <code>last = head = new Node&lt;E&gt;(null);</code> Dummy 节点占位，item 为 null</p>
</li>
</ul>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221108160059498.png" alt="image-20221108160059498" style="zoom:50%;">

<ul>
<li>第一个节点入队 <code>last = last.next = node; </code></li>
</ul>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221108160246755.png" alt="image-20221108160246755" style="zoom:80%;">

<ul>
<li>又一个节点入队 <code>last = last.next = node;</code></li>
</ul>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221108160354474.png" alt="image-20221108160354474" style="zoom:80%;">

<ul>
<li>出队</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;E&gt; h = head;</span><br><span class="line">Node&lt;E&gt; first = h.next;</span><br><span class="line">h.next = h;  <span class="comment">//will GC</span></span><br><span class="line">head = first;</span><br><span class="line"><span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> first.item;</span><br><span class="line">first.item = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">return</span> x;</span><br></pre></td></tr></table></figure>

<ul>
<li>找到 Dummy <code>h = head</code></li>
</ul>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221108160914144.png" alt="image-20221108160914144" style="zoom:80%;">

<ul>
<li>找到第一个元素 <code>first = h.next</code></li>
</ul>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221108160952192.png" alt="image-20221108160952192" style="zoom:80%;">

<ul>
<li>让 Dummy 出队 <code>h.next = h</code></li>
</ul>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221108161040997.png" alt="image-20221108161040997" style="zoom:80%;">

<ul>
<li>第一个元素变成 Dummy <code>head = first</code></li>
</ul>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221108161145230.png" alt="image-20221108161145230" style="zoom:80%;">

<ul>
<li>获取出队元素值<code>E x = first.item; first.item = null; return x ;</code></li>
</ul>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221108161206826.png" alt="image-20221108161206826" style="zoom:80%;">

<p><strong>加锁分析</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于 put（阻塞）offer（非阻塞）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于 take（阻塞）poll（非阻塞）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>两把锁分析</p>
<ul>
<li>同一时刻，允许两个线程（生产者、消费者）同时执行。生产者 - 生产者，消费者 - 消费者串行</li>
</ul>
</li>
<li><p>Dummy 作用</p>
<ul>
<li>保证队列中一直有元素，不会因为两个线程同时初始化队列产生线程安全问题</li>
<li>保证两把锁锁住不同对象</li>
</ul>
</li>
<li><p>线程安全分析</p>
<ul>
<li><p>节点数 &gt;&#x3D; 2 （包括 Dummy）</p>
<blockquote>
<p>putLock 保证 last 节点 线程安全， takeLock 保证 head 节点 线程安全。两把锁保证出队、入队无竞争</p>
</blockquote>
</li>
<li><p>节点数 &lt; 2 （只有 Dummy）</p>
<blockquote>
<p>take 线程会被 notEmpty 条件阻塞</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><strong>源码分析</strong></p>
<p>put 操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 构造新加入的节点，懒惰初始化</span></span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);</span><br><span class="line">    <span class="comment">// 构造锁对象</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putlock;</span><br><span class="line">    <span class="comment">// count 维护元素计数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;</span><br><span class="line">    <span class="comment">// 上锁</span></span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 队列满了，就先等待</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capcity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有空位，入队，计数加一</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="comment">// 还有空位？ 叫醒别的 put 线程</span></span><br><span class="line">        <span class="keyword">if</span>(c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果队列中只有一个元素，叫醒 take 线程</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 这里调用 notEmpty.signal() 而非 notEmpty.signalAll() 是为了减小竞争</span></span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>take 操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="built_in">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">			notEmpty.await();</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		x = dequeue();</span><br><span class="line"> 		c = count.getAndDecrement();</span><br><span class="line"> 		<span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line"> 			notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//other code...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>特点：</p>
<p>都有 put 唤醒 put，take 唤醒 take，以及相互唤醒的操作，为了避免信号不足</p>
</blockquote>
<p><strong>性能比较</strong></p>
<table>
<thead>
<tr>
<th>LinkedBlockingQueue</th>
<th>ArrayBlockingQueue</th>
</tr>
</thead>
<tbody><tr>
<td>支持有界（capacity）</td>
<td>强制有界</td>
</tr>
<tr>
<td>链表</td>
<td>数组</td>
</tr>
<tr>
<td>懒惰初始化</td>
<td>提前初始化 Node 数组</td>
</tr>
<tr>
<td>每次入队生成新的 Node</td>
<td>Node 提前创建好</td>
</tr>
<tr>
<td>两把锁，锁住头&#x2F;尾</td>
<td>一把锁</td>
</tr>
</tbody></table>
<h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><p><strong>特点</strong></p>
<ul>
<li><p>类似于 <code>LinkedBlockingQueue</code></p>
<ul>
<li>有两把锁，锁住队列头和尾，同一时刻允许生产者和消费者两个线程同时执行</li>
<li>有 Dummy 节点，保证两把锁锁住不同对象，保证线程安全</li>
</ul>
</li>
<li><p>不同于<code>LinkedBlockingQueue</code></p>
<ul>
<li>&#x3D;&#x3D;锁用 CAS 实现&#x3D;&#x3D;</li>
</ul>
</li>
</ul>
<p><strong>应用</strong></p>
<ul>
<li>Tomcat 的 Connector 结构中，Acceptor 生产者向 Poller 消费者传递事件消息时，采用了<code>ConcurrentLinkedQueue </code>将<code>SocketChannel</code>给 Poller 使用</li>
</ul>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221111163950793.png" alt="image-20221111163950793" style="zoom:70%;">



<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p><code>CopyOnWriteArraySet</code> 是它的马甲，即 其内部方法都调用了 <code>CopyOnWriteArrayList</code> 的方法。 Set 保证元素无重复的方法是 <code>CopyOnWriteArraySet.add(E e) </code>调用了 <code>CopyOnWriteArrayList.addIfAbsent(E e)</code></p>
<p>底层实现采用&#x3D;&#x3D;写入时拷贝&#x3D;&#x3D;的思想，增删改操作会将底层数组拷贝一份，更改操作在新数组上执行，实现&#x3D;&#x3D;读读并发&#x3D;&#x3D;、&#x3D;&#x3D;读写并发&#x3D;&#x3D;、&#x3D;&#x3D;写写互斥&#x3D;&#x3D;</p>
<p>新增操作加锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock) &#123; </span><br><span class="line">        <span class="comment">//获取旧数组</span></span><br><span class="line">        Object[] es = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> es.length;</span><br><span class="line">        <span class="comment">//拷贝新数组（比较耗时，但不影响其他读线程）</span></span><br><span class="line">        es = Array.copyOf(es, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//添加新元素</span></span><br><span class="line">        es[len] = e;</span><br><span class="line">        <span class="comment">//替换旧数组</span></span><br><span class="line">        setArray(es);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：源码版本为 Java 11，在 Java 1.8 中 使用的是可重入锁</p>
</blockquote>
<p>其他操作未加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer &lt;? <span class="built_in">super</span> E&gt; action)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (Object x : getArray()) &#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E)x;</span><br><span class="line">        action.accept()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用场景：</p>
<p>&#x3D;&#x3D;读多写少&#x3D;&#x3D;，写操作需要拷贝数组，性能消耗更大，但能保证线程安全；读操作可以并发，更为高效</p>
<p><strong>get 弱一致性</strong></p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221108170550392.png" alt="image-20221108170550392" style="zoom:70%;">

<table>
<thead>
<tr>
<th>时间点</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Thread-0 getArray</td>
</tr>
<tr>
<td>2</td>
<td>Thread-1 gerArray</td>
</tr>
<tr>
<td>3</td>
<td>Thread-1 setArray(arrayCopy)</td>
</tr>
<tr>
<td>4</td>
<td>Thread-0 array[index]  &#x2F;&#x2F;读取的是未经修改的旧数组</td>
</tr>
</tbody></table>
<p><strong>迭代器弱一致性</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CopyOnWriteArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">Iterator&lt;Integer&gt; iter = list.iterator();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    list.remove(<span class="number">0</span>);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line">    System.out.println(iter.next());  <span class="comment">//迭代器输出的是旧数组的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：弱一致性未必不好</p>
<ul>
<li>数据库 MVCC 是弱一致性的体现</li>
<li>高并发和一致性是矛盾的，需要权衡</li>
</ul>
</blockquote>

      
       
    </div>
</article>







    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2017 王才雨
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
